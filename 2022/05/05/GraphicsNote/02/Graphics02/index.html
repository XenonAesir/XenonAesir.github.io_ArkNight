<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><title>光栅化成像-光栅化 | X/Ae</title><script>var config = {"hostname":"http://example.com","root":"/","preload":true,"path":"search.json"}</script><script src="//cdnjs.cloudflare.com/ajax/libs/mathjax/2.6.1/MathJax.js"></script><script>MathJax.Hub.Config({
  menuSettings: {
    zoom: "None"
  },
  showMathMenu: false,
  jax: ["input/TeX","output/CommonHTML"],
  extensions: ["tex2jax.js"],
  TeX: {
    extensions: ["AMSmath.js","AMSsymbols.js"],
    equationNumbers: {
      autoNumber: "AMS"
    }
  },
  tex2jax: {
    inlineMath: [["\\(", "\\)"]],
    displayMath: [["\\[", "\\]"]]
  }
});</script><link rel="stylesheet" href="/css/arknights.css"><link rel="stylesheet" href="//unpkg.com/@highlightjs/cdn-assets@11.4.0/styles/atom-one-dark-reasonable.min.css"><style>@font-face {
 font-family: BenderLight;
 src: local('Bender'), url("/font/BenderLight.ttf");
}
@font-face {
 font-family: 'JetBrains Mono';
 src: local('JetBrains Mono'), url('/font/JetBrainsMono-Regular.woff2') format('woff2');
}</style><meta name="generator" content="Hexo 6.1.0"><style>mjx-container[jax="SVG"] {
  direction: ltr;
}

mjx-container[jax="SVG"] > svg {
  overflow: visible;
}

mjx-container[jax="SVG"][display="true"] {
  display: block;
  text-align: center;
  margin: 1em 0;
}

mjx-container[jax="SVG"][justify="left"] {
  text-align: left;
}

mjx-container[jax="SVG"][justify="right"] {
  text-align: right;
}

g[data-mml-node="merror"] > g {
  fill: red;
  stroke: red;
}

g[data-mml-node="merror"] > rect[data-background] {
  fill: yellow;
  stroke: none;
}

g[data-mml-node="mtable"] > line[data-line] {
  stroke-width: 70px;
  fill: none;
}

g[data-mml-node="mtable"] > rect[data-frame] {
  stroke-width: 70px;
  fill: none;
}

g[data-mml-node="mtable"] > .mjx-dashed {
  stroke-dasharray: 140;
}

g[data-mml-node="mtable"] > .mjx-dotted {
  stroke-linecap: round;
  stroke-dasharray: 0,140;
}

g[data-mml-node="mtable"] > svg {
  overflow: visible;
}

[jax="SVG"] mjx-tool {
  display: inline-block;
  position: relative;
  width: 0;
  height: 0;
}

[jax="SVG"] mjx-tool > mjx-tip {
  position: absolute;
  top: 0;
  left: 0;
}

mjx-tool > mjx-tip {
  display: inline-block;
  padding: .2em;
  border: 1px solid #888;
  font-size: 70%;
  background-color: #F8F8F8;
  color: black;
  box-shadow: 2px 2px 5px #AAAAAA;
}

g[data-mml-node="maction"][data-toggle] {
  cursor: pointer;
}

mjx-status {
  display: block;
  position: fixed;
  left: 1em;
  bottom: 1em;
  min-width: 25%;
  padding: .2em .4em;
  border: 1px solid #888;
  font-size: 90%;
  background-color: #F8F8F8;
  color: black;
}

foreignObject[data-mjx-xml] {
  font-family: initial;
  line-height: normal;
  overflow: visible;
}

.MathJax path {
  stroke-width: 3;
}

mjx-container[display="true"] {
  overflow: auto hidden;
}

mjx-container[display="true"] + br {
  display: none;
}
</style></head><body style="background-image:url(https://ak.hypergryph.com/assets/index/images/ak/pc/bk.jpg);"><div id="cursor-container"><div id="cursor-outer"></div><div id="cursor-effect"></div></div><main><header><nav><div class="navBtn"><i class="navBtnIcon"><span class="navBtnIconBar"></span><span class="navBtnIconBar"></span><span class="navBtnIconBar"></span></i></div><ol class="navContent"><li class="navItem search-header"><input autocomplete="off" autocorrect="off" autocapitalize="none" placeholder="数据检索" spellcheck="false" maxlength="50" type="text" id="search-input"></li><li class="navItem"><a href="/"><span class="navItemTitle">Home</span></a></li><li class="navItem"><a href="/archives/"><span class="navItemTitle">Archives</span></a></li><li class="navItem"><a href="/about/"><span class="navItemTitle">About</span></a></li><li class="navItem"><a href="/contact/"><span class="navItemTitle">Contact</span></a></li></ol></nav><div class="search-popup"><div id="search-result"></div></div></header><article><div id="post-bg"><div id="post-title"><h1>光栅化成像-光栅化</h1><div id="post-info"><span>First Post:<span class="control"><time datetime="2022-05-05T15:58:23.000Z" id="date"> 2022-05-05</time></span></span><br><span>Last Update:<span class="control"><time datetime="2022-05-06T02:02:49.825Z" id="updated"> 2022-05-06</time></span></span><br><span>Word Count:<span class="control">&nbsp;5.1k</span></span></div></div><hr><div id="post-content"><h1 id="现代计算机图形学基础入门"><a href="#现代计算机图形学基础入门" class="headerlink" title="现代计算机图形学基础入门"></a>现代计算机图形学基础入门</h1><h2 id="光栅化成像"><a href="#光栅化成像" class="headerlink" title="光栅化成像"></a>光栅化成像</h2><h3 id="光栅化"><a href="#光栅化" class="headerlink" title="光栅化"></a>光栅化</h3><p>本节内容附加资料：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/144330664">计算机图形学三：直线光栅化的数值微分算法,中点Brensenham算法和三角形的光栅化 - 知乎 (zhihu.com)</a></li>
</ul>
<p>在进入具体的直线光栅化以及三角形光栅化算法之前，我们首先需要知道光栅化是一个什么样的过程。</p>
<p><strong>简单来说光栅化的目的就是将想要展现的物体给真正现实到屏幕上的过程</strong>，因为我们的物体其实都是一个个顶点数据来表示的，如何将<strong>这些蕴含几何信息的数据转化为屏幕上的像素点</strong>就是光栅化所考虑的东西。</p>
<p>比如说一条直线，究竟该用哪些像素点去逼近它，一个三角形，又用哪些像素集合表示它，这都是光栅化的过程。</p>
<p>在上一节中物体已经被映射到了屏幕上，那么屏幕是如何显示出来的呢</p>
<h4 id="三角形的光栅化"><a href="#三角形的光栅化" class="headerlink" title="三角形的光栅化"></a>三角形的光栅化</h4><p>为什么不是四边形五边形的光栅化，偏偏要谈三角形呢，因为三角形是最基本的多边形，大部分的模型都是用一个个三角形面表示，且任意的其它多边形其实都可以转化成多个三角形的形式，因此三角形的光栅化可以说是图形学中最基础的部分了。</p>
<p><img src="/2022/05/05/GraphicsNote/02/Graphics02/image-20220329190734117.png" alt="image-20220329190734117"></p>
<p>那么三角形会在屏幕上被显示成什么呢</p>
<p><img src="/2022/05/05/GraphicsNote/02/Graphics02/image-20220329192231788.png" alt="image-20220329192231788"></p>
<h5 id="离散化三角形"><a href="#离散化三角形" class="headerlink" title="离散化三角形"></a>离散化三角形</h5><p>做到这一步我们需要<strong>采样</strong></p>
<p><strong>请注意，采样的概念在接下来的文章中将会出现多次</strong></p>
<p>概念化解释：取样也叫采样，是把连续的模拟量用一个个离散的点来表示。将时间轴上连续的信号每隔一定的时间间隔抽取出一个信号的幅度样本，使其成为时间上离散的脉冲序列。</p>
<p><img src="/2022/05/05/GraphicsNote/02/Graphics02/image-20220329192448407.png" alt="image-20220329192448407"></p>
<p>如果我们将各个像素的中心点是否在三角形中作为唯一的判定标准，那么三角形将会被这样显示</p>
<p><img src="/2022/05/05/GraphicsNote/02/Graphics02/image-20220329192924128.png" alt="image-20220329192924128"></p>
<p><img src="/2022/05/05/GraphicsNote/02/Graphics02/image-20220329193030706.png" alt="image-20220329193030706"></p>
<p>对应的伪代码如下</p>
<p><img src="/2022/05/05/GraphicsNote/02/Graphics02/image-20220329192937413.png" alt="image-20220329192937413"></p>
<p>经过这样的简单采样，三角形将会被这样显示出来</p>
<p><img src="/2022/05/05/GraphicsNote/02/Graphics02/image-20220329192755803.png" alt="image-20220329192755803"></p>
<h5 id="内与外"><a href="#内与外" class="headerlink" title="内与外"></a>内与外</h5><p>上面提到的采样是针对整个屏幕空间进行的，其中有一个函数inside(…)负责返回像素判定点是否在三角形内，我们该如何实现它呢</p>
<p><img src="/2022/05/05/GraphicsNote/02/Graphics02/image-20220329194206955.png" alt="image-20220329194206955"></p>
<p>例如在这幅图中，该如何判断任意一点<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.439ex" xmlns="http://www.w3.org/2000/svg" width="1.79ex" height="2.032ex" role="img" focusable="false" viewbox="0 -704 791 898"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D444" d="M399 -80Q399 -47 400 -30T402 -11V-7L387 -11Q341 -22 303 -22Q208 -22 138 35T51 201Q50 209 50 244Q50 346 98 438T227 601Q351 704 476 704Q514 704 524 703Q621 689 680 617T740 435Q740 255 592 107Q529 47 461 16L444 8V3Q444 2 449 -24T470 -66T516 -82Q551 -82 583 -60T625 -3Q631 11 638 11Q647 11 649 2Q649 -6 639 -34T611 -100T557 -165T481 -194Q399 -194 399 -87V-80ZM636 468Q636 523 621 564T580 625T530 655T477 665Q429 665 379 640Q277 591 215 464T153 216Q153 110 207 59Q231 38 236 38V46Q236 86 269 120T347 155Q372 155 390 144T417 114T429 82T435 55L448 64Q512 108 557 185T619 334T636 468ZM314 18Q362 18 404 39L403 49Q399 104 366 115Q354 117 347 117Q344 117 341 117T337 118Q317 118 296 98T274 52Q274 18 314 18Z"/></g></g></g></svg></mjx-container>是否在三角形<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.375ex" xmlns="http://www.w3.org/2000/svg" width="7.32ex" height="1.92ex" role="img" focusable="false" viewbox="0 -683 3235.7 848.6"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msub"><g data-mml-node="mi"><path data-c="1D443" d="M287 628Q287 635 230 637Q206 637 199 638T192 648Q192 649 194 659Q200 679 203 681T397 683Q587 682 600 680Q664 669 707 631T751 530Q751 453 685 389Q616 321 507 303Q500 302 402 301H307L277 182Q247 66 247 59Q247 55 248 54T255 50T272 48T305 46H336Q342 37 342 35Q342 19 335 5Q330 0 319 0Q316 0 282 1T182 2Q120 2 87 2T51 1Q33 1 33 11Q33 13 36 25Q40 41 44 43T67 46Q94 46 127 49Q141 52 146 61Q149 65 218 339T287 628ZM645 554Q645 567 643 575T634 597T609 619T560 635Q553 636 480 637Q463 637 445 637T416 636T404 636Q391 635 386 627Q384 621 367 550T332 412T314 344Q314 342 395 342H407H430Q542 342 590 392Q617 419 631 471T645 554Z"/></g><g data-mml-node="mn" transform="translate(675,-150) scale(0.707)"><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"/></g></g><g data-mml-node="msub" transform="translate(1078.6,0)"><g data-mml-node="mi"><path data-c="1D443" d="M287 628Q287 635 230 637Q206 637 199 638T192 648Q192 649 194 659Q200 679 203 681T397 683Q587 682 600 680Q664 669 707 631T751 530Q751 453 685 389Q616 321 507 303Q500 302 402 301H307L277 182Q247 66 247 59Q247 55 248 54T255 50T272 48T305 46H336Q342 37 342 35Q342 19 335 5Q330 0 319 0Q316 0 282 1T182 2Q120 2 87 2T51 1Q33 1 33 11Q33 13 36 25Q40 41 44 43T67 46Q94 46 127 49Q141 52 146 61Q149 65 218 339T287 628ZM645 554Q645 567 643 575T634 597T609 619T560 635Q553 636 480 637Q463 637 445 637T416 636T404 636Q391 635 386 627Q384 621 367 550T332 412T314 344Q314 342 395 342H407H430Q542 342 590 392Q617 419 631 471T645 554Z"/></g><g data-mml-node="mn" transform="translate(675,-150) scale(0.707)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"/></g></g><g data-mml-node="msub" transform="translate(2157.1,0)"><g data-mml-node="mi"><path data-c="1D443" d="M287 628Q287 635 230 637Q206 637 199 638T192 648Q192 649 194 659Q200 679 203 681T397 683Q587 682 600 680Q664 669 707 631T751 530Q751 453 685 389Q616 321 507 303Q500 302 402 301H307L277 182Q247 66 247 59Q247 55 248 54T255 50T272 48T305 46H336Q342 37 342 35Q342 19 335 5Q330 0 319 0Q316 0 282 1T182 2Q120 2 87 2T51 1Q33 1 33 11Q33 13 36 25Q40 41 44 43T67 46Q94 46 127 49Q141 52 146 61Q149 65 218 339T287 628ZM645 554Q645 567 643 575T634 597T609 619T560 635Q553 636 480 637Q463 637 445 637T416 636T404 636Q391 635 386 627Q384 621 367 550T332 412T314 344Q314 342 395 342H407H430Q542 342 590 392Q617 419 631 471T645 554Z"/></g><g data-mml-node="mn" transform="translate(675,-150) scale(0.707)"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"/></g></g></g></g></svg></mjx-container>之内呢</p>
<p>利用<strong>叉乘的性质</strong>，如果满足</p>
<ul>
<li><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.439ex" xmlns="http://www.w3.org/2000/svg" width="10.87ex" height="2.032ex" role="img" focusable="false" viewbox="0 -704 4804.7 898"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msub"><g data-mml-node="mi"><path data-c="1D443" d="M287 628Q287 635 230 637Q206 637 199 638T192 648Q192 649 194 659Q200 679 203 681T397 683Q587 682 600 680Q664 669 707 631T751 530Q751 453 685 389Q616 321 507 303Q500 302 402 301H307L277 182Q247 66 247 59Q247 55 248 54T255 50T272 48T305 46H336Q342 37 342 35Q342 19 335 5Q330 0 319 0Q316 0 282 1T182 2Q120 2 87 2T51 1Q33 1 33 11Q33 13 36 25Q40 41 44 43T67 46Q94 46 127 49Q141 52 146 61Q149 65 218 339T287 628ZM645 554Q645 567 643 575T634 597T609 619T560 635Q553 636 480 637Q463 637 445 637T416 636T404 636Q391 635 386 627Q384 621 367 550T332 412T314 344Q314 342 395 342H407H430Q542 342 590 392Q617 419 631 471T645 554Z"/></g><g data-mml-node="mn" transform="translate(675,-150) scale(0.707)"><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"/></g></g><g data-mml-node="msub" transform="translate(1078.6,0)"><g data-mml-node="mi"><path data-c="1D443" d="M287 628Q287 635 230 637Q206 637 199 638T192 648Q192 649 194 659Q200 679 203 681T397 683Q587 682 600 680Q664 669 707 631T751 530Q751 453 685 389Q616 321 507 303Q500 302 402 301H307L277 182Q247 66 247 59Q247 55 248 54T255 50T272 48T305 46H336Q342 37 342 35Q342 19 335 5Q330 0 319 0Q316 0 282 1T182 2Q120 2 87 2T51 1Q33 1 33 11Q33 13 36 25Q40 41 44 43T67 46Q94 46 127 49Q141 52 146 61Q149 65 218 339T287 628ZM645 554Q645 567 643 575T634 597T609 619T560 635Q553 636 480 637Q463 637 445 637T416 636T404 636Q391 635 386 627Q384 621 367 550T332 412T314 344Q314 342 395 342H407H430Q542 342 590 392Q617 419 631 471T645 554Z"/></g><g data-mml-node="mn" transform="translate(675,-150) scale(0.707)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"/></g></g><g data-mml-node="mi" transform="translate(2157.1,0)"><path data-c="D7" d="M630 29Q630 9 609 9Q604 9 587 25T493 118L389 222L284 117Q178 13 175 11Q171 9 168 9Q160 9 154 15T147 29Q147 36 161 51T255 146L359 250L255 354Q174 435 161 449T147 471Q147 480 153 485T168 490Q173 490 175 489Q178 487 284 383L389 278L493 382Q570 459 587 475T609 491Q630 491 630 471Q630 464 620 453T522 355L418 250L522 145Q606 61 618 48T630 29Z"/></g><g data-mml-node="msub" transform="translate(2935.1,0)"><g data-mml-node="mi"><path data-c="1D443" d="M287 628Q287 635 230 637Q206 637 199 638T192 648Q192 649 194 659Q200 679 203 681T397 683Q587 682 600 680Q664 669 707 631T751 530Q751 453 685 389Q616 321 507 303Q500 302 402 301H307L277 182Q247 66 247 59Q247 55 248 54T255 50T272 48T305 46H336Q342 37 342 35Q342 19 335 5Q330 0 319 0Q316 0 282 1T182 2Q120 2 87 2T51 1Q33 1 33 11Q33 13 36 25Q40 41 44 43T67 46Q94 46 127 49Q141 52 146 61Q149 65 218 339T287 628ZM645 554Q645 567 643 575T634 597T609 619T560 635Q553 636 480 637Q463 637 445 637T416 636T404 636Q391 635 386 627Q384 621 367 550T332 412T314 344Q314 342 395 342H407H430Q542 342 590 392Q617 419 631 471T645 554Z"/></g><g data-mml-node="mn" transform="translate(675,-150) scale(0.707)"><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"/></g></g><g data-mml-node="mi" transform="translate(4013.7,0)"><path data-c="1D444" d="M399 -80Q399 -47 400 -30T402 -11V-7L387 -11Q341 -22 303 -22Q208 -22 138 35T51 201Q50 209 50 244Q50 346 98 438T227 601Q351 704 476 704Q514 704 524 703Q621 689 680 617T740 435Q740 255 592 107Q529 47 461 16L444 8V3Q444 2 449 -24T470 -66T516 -82Q551 -82 583 -60T625 -3Q631 11 638 11Q647 11 649 2Q649 -6 639 -34T611 -100T557 -165T481 -194Q399 -194 399 -87V-80ZM636 468Q636 523 621 564T580 625T530 655T477 665Q429 665 379 640Q277 591 215 464T153 216Q153 110 207 59Q231 38 236 38V46Q236 86 269 120T347 155Q372 155 390 144T417 114T429 82T435 55L448 64Q512 108 557 185T619 334T636 468ZM314 18Q362 18 404 39L403 49Q399 104 366 115Q354 117 347 117Q344 117 341 117T337 118Q317 118 296 98T274 52Q274 18 314 18Z"/></g></g></g></svg></mjx-container></li>
<li><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.439ex" xmlns="http://www.w3.org/2000/svg" width="10.87ex" height="2.032ex" role="img" focusable="false" viewbox="0 -704 4804.7 898"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msub"><g data-mml-node="mi"><path data-c="1D443" d="M287 628Q287 635 230 637Q206 637 199 638T192 648Q192 649 194 659Q200 679 203 681T397 683Q587 682 600 680Q664 669 707 631T751 530Q751 453 685 389Q616 321 507 303Q500 302 402 301H307L277 182Q247 66 247 59Q247 55 248 54T255 50T272 48T305 46H336Q342 37 342 35Q342 19 335 5Q330 0 319 0Q316 0 282 1T182 2Q120 2 87 2T51 1Q33 1 33 11Q33 13 36 25Q40 41 44 43T67 46Q94 46 127 49Q141 52 146 61Q149 65 218 339T287 628ZM645 554Q645 567 643 575T634 597T609 619T560 635Q553 636 480 637Q463 637 445 637T416 636T404 636Q391 635 386 627Q384 621 367 550T332 412T314 344Q314 342 395 342H407H430Q542 342 590 392Q617 419 631 471T645 554Z"/></g><g data-mml-node="mn" transform="translate(675,-150) scale(0.707)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"/></g></g><g data-mml-node="msub" transform="translate(1078.6,0)"><g data-mml-node="mi"><path data-c="1D443" d="M287 628Q287 635 230 637Q206 637 199 638T192 648Q192 649 194 659Q200 679 203 681T397 683Q587 682 600 680Q664 669 707 631T751 530Q751 453 685 389Q616 321 507 303Q500 302 402 301H307L277 182Q247 66 247 59Q247 55 248 54T255 50T272 48T305 46H336Q342 37 342 35Q342 19 335 5Q330 0 319 0Q316 0 282 1T182 2Q120 2 87 2T51 1Q33 1 33 11Q33 13 36 25Q40 41 44 43T67 46Q94 46 127 49Q141 52 146 61Q149 65 218 339T287 628ZM645 554Q645 567 643 575T634 597T609 619T560 635Q553 636 480 637Q463 637 445 637T416 636T404 636Q391 635 386 627Q384 621 367 550T332 412T314 344Q314 342 395 342H407H430Q542 342 590 392Q617 419 631 471T645 554Z"/></g><g data-mml-node="mn" transform="translate(675,-150) scale(0.707)"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"/></g></g><g data-mml-node="mi" transform="translate(2157.1,0)"><path data-c="D7" d="M630 29Q630 9 609 9Q604 9 587 25T493 118L389 222L284 117Q178 13 175 11Q171 9 168 9Q160 9 154 15T147 29Q147 36 161 51T255 146L359 250L255 354Q174 435 161 449T147 471Q147 480 153 485T168 490Q173 490 175 489Q178 487 284 383L389 278L493 382Q570 459 587 475T609 491Q630 491 630 471Q630 464 620 453T522 355L418 250L522 145Q606 61 618 48T630 29Z"/></g><g data-mml-node="msub" transform="translate(2935.1,0)"><g data-mml-node="mi"><path data-c="1D443" d="M287 628Q287 635 230 637Q206 637 199 638T192 648Q192 649 194 659Q200 679 203 681T397 683Q587 682 600 680Q664 669 707 631T751 530Q751 453 685 389Q616 321 507 303Q500 302 402 301H307L277 182Q247 66 247 59Q247 55 248 54T255 50T272 48T305 46H336Q342 37 342 35Q342 19 335 5Q330 0 319 0Q316 0 282 1T182 2Q120 2 87 2T51 1Q33 1 33 11Q33 13 36 25Q40 41 44 43T67 46Q94 46 127 49Q141 52 146 61Q149 65 218 339T287 628ZM645 554Q645 567 643 575T634 597T609 619T560 635Q553 636 480 637Q463 637 445 637T416 636T404 636Q391 635 386 627Q384 621 367 550T332 412T314 344Q314 342 395 342H407H430Q542 342 590 392Q617 419 631 471T645 554Z"/></g><g data-mml-node="mn" transform="translate(675,-150) scale(0.707)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"/></g></g><g data-mml-node="mi" transform="translate(4013.7,0)"><path data-c="1D444" d="M399 -80Q399 -47 400 -30T402 -11V-7L387 -11Q341 -22 303 -22Q208 -22 138 35T51 201Q50 209 50 244Q50 346 98 438T227 601Q351 704 476 704Q514 704 524 703Q621 689 680 617T740 435Q740 255 592 107Q529 47 461 16L444 8V3Q444 2 449 -24T470 -66T516 -82Q551 -82 583 -60T625 -3Q631 11 638 11Q647 11 649 2Q649 -6 639 -34T611 -100T557 -165T481 -194Q399 -194 399 -87V-80ZM636 468Q636 523 621 564T580 625T530 655T477 665Q429 665 379 640Q277 591 215 464T153 216Q153 110 207 59Q231 38 236 38V46Q236 86 269 120T347 155Q372 155 390 144T417 114T429 82T435 55L448 64Q512 108 557 185T619 334T636 468ZM314 18Q362 18 404 39L403 49Q399 104 366 115Q354 117 347 117Q344 117 341 117T337 118Q317 118 296 98T274 52Q274 18 314 18Z"/></g></g></g></svg></mjx-container></li>
<li><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.439ex" xmlns="http://www.w3.org/2000/svg" width="10.87ex" height="2.032ex" role="img" focusable="false" viewbox="0 -704 4804.7 898"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msub"><g data-mml-node="mi"><path data-c="1D443" d="M287 628Q287 635 230 637Q206 637 199 638T192 648Q192 649 194 659Q200 679 203 681T397 683Q587 682 600 680Q664 669 707 631T751 530Q751 453 685 389Q616 321 507 303Q500 302 402 301H307L277 182Q247 66 247 59Q247 55 248 54T255 50T272 48T305 46H336Q342 37 342 35Q342 19 335 5Q330 0 319 0Q316 0 282 1T182 2Q120 2 87 2T51 1Q33 1 33 11Q33 13 36 25Q40 41 44 43T67 46Q94 46 127 49Q141 52 146 61Q149 65 218 339T287 628ZM645 554Q645 567 643 575T634 597T609 619T560 635Q553 636 480 637Q463 637 445 637T416 636T404 636Q391 635 386 627Q384 621 367 550T332 412T314 344Q314 342 395 342H407H430Q542 342 590 392Q617 419 631 471T645 554Z"/></g><g data-mml-node="mn" transform="translate(675,-150) scale(0.707)"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"/></g></g><g data-mml-node="msub" transform="translate(1078.6,0)"><g data-mml-node="mi"><path data-c="1D443" d="M287 628Q287 635 230 637Q206 637 199 638T192 648Q192 649 194 659Q200 679 203 681T397 683Q587 682 600 680Q664 669 707 631T751 530Q751 453 685 389Q616 321 507 303Q500 302 402 301H307L277 182Q247 66 247 59Q247 55 248 54T255 50T272 48T305 46H336Q342 37 342 35Q342 19 335 5Q330 0 319 0Q316 0 282 1T182 2Q120 2 87 2T51 1Q33 1 33 11Q33 13 36 25Q40 41 44 43T67 46Q94 46 127 49Q141 52 146 61Q149 65 218 339T287 628ZM645 554Q645 567 643 575T634 597T609 619T560 635Q553 636 480 637Q463 637 445 637T416 636T404 636Q391 635 386 627Q384 621 367 550T332 412T314 344Q314 342 395 342H407H430Q542 342 590 392Q617 419 631 471T645 554Z"/></g><g data-mml-node="mn" transform="translate(675,-150) scale(0.707)"><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"/></g></g><g data-mml-node="mi" transform="translate(2157.1,0)"><path data-c="D7" d="M630 29Q630 9 609 9Q604 9 587 25T493 118L389 222L284 117Q178 13 175 11Q171 9 168 9Q160 9 154 15T147 29Q147 36 161 51T255 146L359 250L255 354Q174 435 161 449T147 471Q147 480 153 485T168 490Q173 490 175 489Q178 487 284 383L389 278L493 382Q570 459 587 475T609 491Q630 491 630 471Q630 464 620 453T522 355L418 250L522 145Q606 61 618 48T630 29Z"/></g><g data-mml-node="msub" transform="translate(2935.1,0)"><g data-mml-node="mi"><path data-c="1D443" d="M287 628Q287 635 230 637Q206 637 199 638T192 648Q192 649 194 659Q200 679 203 681T397 683Q587 682 600 680Q664 669 707 631T751 530Q751 453 685 389Q616 321 507 303Q500 302 402 301H307L277 182Q247 66 247 59Q247 55 248 54T255 50T272 48T305 46H336Q342 37 342 35Q342 19 335 5Q330 0 319 0Q316 0 282 1T182 2Q120 2 87 2T51 1Q33 1 33 11Q33 13 36 25Q40 41 44 43T67 46Q94 46 127 49Q141 52 146 61Q149 65 218 339T287 628ZM645 554Q645 567 643 575T634 597T609 619T560 635Q553 636 480 637Q463 637 445 637T416 636T404 636Q391 635 386 627Q384 621 367 550T332 412T314 344Q314 342 395 342H407H430Q542 342 590 392Q617 419 631 471T645 554Z"/></g><g data-mml-node="mn" transform="translate(675,-150) scale(0.707)"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"/></g></g><g data-mml-node="mi" transform="translate(4013.7,0)"><path data-c="1D444" d="M399 -80Q399 -47 400 -30T402 -11V-7L387 -11Q341 -22 303 -22Q208 -22 138 35T51 201Q50 209 50 244Q50 346 98 438T227 601Q351 704 476 704Q514 704 524 703Q621 689 680 617T740 435Q740 255 592 107Q529 47 461 16L444 8V3Q444 2 449 -24T470 -66T516 -82Q551 -82 583 -60T625 -3Q631 11 638 11Q647 11 649 2Q649 -6 639 -34T611 -100T557 -165T481 -194Q399 -194 399 -87V-80ZM636 468Q636 523 621 564T580 625T530 655T477 665Q429 665 379 640Q277 591 215 464T153 216Q153 110 207 59Q231 38 236 38V46Q236 86 269 120T347 155Q372 155 390 144T417 114T429 82T435 55L448 64Q512 108 557 185T619 334T636 468ZM314 18Q362 18 404 39L403 49Q399 104 366 115Q354 117 347 117Q344 117 341 117T337 118Q317 118 296 98T274 52Q274 18 314 18Z"/></g></g></g></svg></mjx-container></li>
</ul>
<p>以上三个多项式结果同号，则点<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.439ex" xmlns="http://www.w3.org/2000/svg" width="1.79ex" height="2.032ex" role="img" focusable="false" viewbox="0 -704 791 898"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D444" d="M399 -80Q399 -47 400 -30T402 -11V-7L387 -11Q341 -22 303 -22Q208 -22 138 35T51 201Q50 209 50 244Q50 346 98 438T227 601Q351 704 476 704Q514 704 524 703Q621 689 680 617T740 435Q740 255 592 107Q529 47 461 16L444 8V3Q444 2 449 -24T470 -66T516 -82Q551 -82 583 -60T625 -3Q631 11 638 11Q647 11 649 2Q649 -6 639 -34T611 -100T557 -165T481 -194Q399 -194 399 -87V-80ZM636 468Q636 523 621 564T580 625T530 655T477 665Q429 665 379 640Q277 591 215 464T153 216Q153 110 207 59Q231 38 236 38V46Q236 86 269 120T347 155Q372 155 390 144T417 114T429 82T435 55L448 64Q512 108 557 185T619 334T636 468ZM314 18Q362 18 404 39L403 49Q399 104 366 115Q354 117 347 117Q344 117 341 117T337 118Q317 118 296 98T274 52Q274 18 314 18Z"/></g></g></g></svg></mjx-container>在三角形<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.375ex" xmlns="http://www.w3.org/2000/svg" width="7.32ex" height="1.92ex" role="img" focusable="false" viewbox="0 -683 3235.7 848.6"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msub"><g data-mml-node="mi"><path data-c="1D443" d="M287 628Q287 635 230 637Q206 637 199 638T192 648Q192 649 194 659Q200 679 203 681T397 683Q587 682 600 680Q664 669 707 631T751 530Q751 453 685 389Q616 321 507 303Q500 302 402 301H307L277 182Q247 66 247 59Q247 55 248 54T255 50T272 48T305 46H336Q342 37 342 35Q342 19 335 5Q330 0 319 0Q316 0 282 1T182 2Q120 2 87 2T51 1Q33 1 33 11Q33 13 36 25Q40 41 44 43T67 46Q94 46 127 49Q141 52 146 61Q149 65 218 339T287 628ZM645 554Q645 567 643 575T634 597T609 619T560 635Q553 636 480 637Q463 637 445 637T416 636T404 636Q391 635 386 627Q384 621 367 550T332 412T314 344Q314 342 395 342H407H430Q542 342 590 392Q617 419 631 471T645 554Z"/></g><g data-mml-node="mn" transform="translate(675,-150) scale(0.707)"><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"/></g></g><g data-mml-node="msub" transform="translate(1078.6,0)"><g data-mml-node="mi"><path data-c="1D443" d="M287 628Q287 635 230 637Q206 637 199 638T192 648Q192 649 194 659Q200 679 203 681T397 683Q587 682 600 680Q664 669 707 631T751 530Q751 453 685 389Q616 321 507 303Q500 302 402 301H307L277 182Q247 66 247 59Q247 55 248 54T255 50T272 48T305 46H336Q342 37 342 35Q342 19 335 5Q330 0 319 0Q316 0 282 1T182 2Q120 2 87 2T51 1Q33 1 33 11Q33 13 36 25Q40 41 44 43T67 46Q94 46 127 49Q141 52 146 61Q149 65 218 339T287 628ZM645 554Q645 567 643 575T634 597T609 619T560 635Q553 636 480 637Q463 637 445 637T416 636T404 636Q391 635 386 627Q384 621 367 550T332 412T314 344Q314 342 395 342H407H430Q542 342 590 392Q617 419 631 471T645 554Z"/></g><g data-mml-node="mn" transform="translate(675,-150) scale(0.707)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"/></g></g><g data-mml-node="msub" transform="translate(2157.1,0)"><g data-mml-node="mi"><path data-c="1D443" d="M287 628Q287 635 230 637Q206 637 199 638T192 648Q192 649 194 659Q200 679 203 681T397 683Q587 682 600 680Q664 669 707 631T751 530Q751 453 685 389Q616 321 507 303Q500 302 402 301H307L277 182Q247 66 247 59Q247 55 248 54T255 50T272 48T305 46H336Q342 37 342 35Q342 19 335 5Q330 0 319 0Q316 0 282 1T182 2Q120 2 87 2T51 1Q33 1 33 11Q33 13 36 25Q40 41 44 43T67 46Q94 46 127 49Q141 52 146 61Q149 65 218 339T287 628ZM645 554Q645 567 643 575T634 597T609 619T560 635Q553 636 480 637Q463 637 445 637T416 636T404 636Q391 635 386 627Q384 621 367 550T332 412T314 344Q314 342 395 342H407H430Q542 342 590 392Q617 419 631 471T645 554Z"/></g><g data-mml-node="mn" transform="translate(675,-150) scale(0.707)"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"/></g></g></g></g></svg></mjx-container>内，否则不在</p>
<h5 id="边界情况"><a href="#边界情况" class="headerlink" title="边界情况"></a>边界情况</h5><p>如果空间中有多个三角形，而一个像素采样点恰巧在这两个三角形的边界处，那该如何判定呢</p>
<p><img src="/2022/05/05/GraphicsNote/02/Graphics02/image-20220329200751279.png" alt="image-20220329200751279"></p>
<p>对于这种情况需要自己进行判断，并没有统一标准，我们需要知道图形学的宗旨：<strong>看起来真实就可以</strong></p>
<h5 id="优化方法"><a href="#优化方法" class="headerlink" title="优化方法"></a>优化方法</h5><p>因此自然的，只需要遍历每一个点就可以得出三角形的光栅化结果了，当然我们还可以进一步的进行优化，因为显然并没有必要去测试屏幕中的每一个点，一个三角形面可能只占屏幕很小的部分，可以利用一个包围盒（bounding box）包围住想要测试的三角形，只对该包围盒内的点进行采样测试</p>
<p><img src="/2022/05/05/GraphicsNote/02/Graphics02/image-20220329200634160.png" alt="image-20220329200634160"></p>
<p>除了包围盒外还有多种优化方法，例如在下面这幅图中，找到第一个判定成功的像素点后，直接进行后续同行的判定</p>
<p><img src="/2022/05/05/GraphicsNote/02/Graphics02/image-20220329201100034.png" alt="image-20220329201100034"></p>
<p>不同的方法适用于不同的情况，请灵活使用</p>
<h4 id="走样与反走样"><a href="#走样与反走样" class="headerlink" title="走样与反走样"></a>走样与反走样</h4><p>如果我们就此结束，将上一节中采样得到的离散化三角形显示出来的话，会是这种情况</p>
<p><img src="/2022/05/05/GraphicsNote/02/Graphics02/image-20220329202224544.png" alt="image-20220329202224544"></p>
<p>发生这种不真实的，我们不想要的现象被称为<strong>走样</strong>，走样产生的原因是<strong>采样不足</strong>，即采样量变化的过快，而采样速率跟不上，这里出现了多个名词，我们将会一一解释</p>
<h5 id="走样-Aliasing"><a href="#走样-Aliasing" class="headerlink" title="走样 Aliasing"></a>走样 Aliasing</h5><p>一张图片被放大会出现锯齿、拍摄电脑屏幕会出现奇怪的波纹、快速转动的车轮会看起来像是在倒转。这些现象都可以被称为“走样”，产生的原因即是“采样”不足。</p>
<p>以上提到的三种情况分别对应以下名词：锯齿、摩尔纹以及车轮效应。</p>
<p><img src="/2022/05/05/GraphicsNote/02/Graphics02/image-20220330191600609.png" alt="image-20220330191600609"></p>
<p><img src="/2022/05/05/GraphicsNote/02/Graphics02/image-20220330191622753.png" alt="image-20220330191622753"></p>
<p>其中锯齿与摩尔纹是屏幕在空间上的采样不足，而发生在现实中的倒转车轮效果则是大脑对光线的时间的采样不足。</p>
<h5 id="采样-Sample"><a href="#采样-Sample" class="headerlink" title="采样 Sample"></a>采样 Sample</h5><p>采样又名抽样，就像检测工厂中产品合格率使用的抽样调查一样</p>
<p><strong>采样在信号处理上有更多的含义，在这里不过多叙述，仅仅介绍一些基础概念</strong></p>
<p>上文已经提过，出现走样的原因是<strong>采样量变化的过快，而采样速率跟不上</strong>，如图所示</p>
<p><img src="/2022/05/05/GraphicsNote/02/Graphics02/image-20220330192718447.png" alt="image-20220330192718447"></p>
<p>使用同样的采样速率，不同频率的函数采样后的效果不同，可以观察到频率高的失真度越大</p>
<p>在更极端一点的情况下，两种截然不同的信号在一种采样方式下，可能会得到完全相同的结果</p>
<p><img src="/2022/05/05/GraphicsNote/02/Graphics02/image-20220330193203407.png" alt="image-20220330193203407"></p>
<h6 id="滤波-Filtering"><a href="#滤波-Filtering" class="headerlink" title="滤波 Filtering"></a>滤波 Filtering</h6><p>首先我们来看一下，一张图片经过<strong>傅里叶变换</strong>后从时域转变为频域的效果</p>
<p><img src="/2022/05/05/GraphicsNote/02/Graphics02/image-20220330193815732.png" alt="image-20220330193815732"></p>
<p>右侧这张图像的含义是</p>
<ul>
<li>中心点为低频信号，四周为高频信号</li>
<li>十字效果产生的原因是图像非四方连续，导致信号的突变</li>
</ul>
<p>如果你还记得之前提到的内容的话，你就能知道这里的低频与高频的含义</p>
<ul>
<li>低频信号指颜色变换程度较小的地方</li>
<li>高频信号值颜色变换程度较大的地方</li>
</ul>
<p>那么如果可以对图像的信号进行处理以后，再使用逆傅里叶变换逆向回图像会产生什么效果呢</p>
<p><strong>滤波</strong>：将信号中特定波段频率滤除的操作</p>
<p><img src="/2022/05/05/GraphicsNote/02/Graphics02/image-20220330194249398.png" alt="image-20220330194249398"></p>
<p><img src="/2022/05/05/GraphicsNote/02/Graphics02/image-20220330194259918.png" alt="image-20220330194259918"></p>
<p>当然还可以对特定频段的信号进行过滤，产生出介于两者之间的效果</p>
<p><img src="/2022/05/05/GraphicsNote/02/Graphics02/image-20220330195414513.png" alt="image-20220330195414513"></p>
<h6 id="卷积-Convolution"><a href="#卷积-Convolution" class="headerlink" title="卷积 Convolution"></a>卷积 Convolution</h6><p><strong>这里的卷积是图形学上简化版本的卷积</strong></p>
<p>例如在如下的操作中</p>
<p><img src="/2022/05/05/GraphicsNote/02/Graphics02/image-20220330202058951.png" alt="image-20220330202058951"></p>
<p>在Result中计算的结果，是Signal中的值经过Filter（卷积核/滤波器）对周围值按权取值平均计算出的结果</p>
<p><img src="/2022/05/05/GraphicsNote/02/Graphics02/image-20220330202110849.png" alt="image-20220330202110849"></p>
<p>并依次往下进行，直至计算完Signal中的所有值</p>
<p>卷积有如下定理</p>
<p><strong>在时域中的卷积，等于在频域中的乘积</strong></p>
<p><strong>在时域中的乘积，等于在频域中的卷积</strong></p>
<p>由此在应用卷积时有以下两种路线</p>
<p>一：</p>
<ul>
<li>在时域中使用卷积滤波</li>
</ul>
<p>二：</p>
<ul>
<li>使用傅里叶变换从时域转换为频域</li>
<li>点乘由傅里叶变换来的卷积核</li>
<li>使用逆傅里叶变换从频域转换为时域</li>
</ul>
<p>下图解释了这一定理，两种路线可以得到相同的效果</p>
<p><img src="/2022/05/05/GraphicsNote/02/Graphics02/image-20220330203204228.png" alt="image-20220330203204228"></p>
<h6 id="滤波器-Filter"><a href="#滤波器-Filter" class="headerlink" title="滤波器 Filter"></a>滤波器 Filter</h6><p>滤波器有许多种，在此仅仅介绍一种盒状滤波器（Box Filter）</p>
<p><img src="/2022/05/05/GraphicsNote/02/Graphics02/image-20220330205320937.png" alt="image-20220330205320937"></p>
<p>将这个滤波器表示为图像如下</p>
<p><img src="/2022/05/05/GraphicsNote/02/Graphics02/image-20220330205336326.png" alt="image-20220330205336326"></p>
<p><img src="/2022/05/05/GraphicsNote/02/Graphics02/image-20220330205345971.png" alt="image-20220330205345971"></p>
<ul>
<li>盒子的大小也有影响，<strong>更大的滤波器会使得图像丧失更多高频信号，即更加模糊</strong></li>
</ul>
<p>这一点可以这么思考</p>
<ul>
<li>如果盒子超过了图像尺寸，那么将会只显示出一个颜色</li>
<li>如果盒子等于一个像素的大小，那么相当于没有做任何处理</li>
</ul>
<h6 id="时域-Spatial-Domain与频域-Frequency-Domain上的采样"><a href="#时域-Spatial-Domain与频域-Frequency-Domain上的采样" class="headerlink" title="时域 Spatial Domain与频域 Frequency Domain上的采样"></a>时域 Spatial Domain与频域 Frequency Domain上的采样</h6><p><img src="/2022/05/05/GraphicsNote/02/Graphics02/image-20220330221911118.png" alt="image-20220330221911118"></p>
<p>图中左侧为时域，右侧为频域，对应关系为</p>
<ul>
<li>左侧经过傅里叶变换可得到右侧</li>
<li>左侧区域的采样（a）乘上（c）冲激函数得到结果（e）,与此对应的频域操作则为卷积，即右侧的操作过程</li>
<li>表现结果为（f）不断在冲激函数上重复的频谱</li>
</ul>
<p>我们不需要过多理解这些内容，这里我们只要知道<strong>在频域上的采样效果：在冲激函数上不断重复的频谱</strong></p>
<p><img src="/2022/05/05/GraphicsNote/02/Graphics02/image-20220331170738583.png" alt="image-20220331170738583"></p>
<p>如图所示，上图是一种在频域的临界采样情况，<strong>若采样时采样间隔变大，则导致采样频率降低，不同的频谱会堆叠在一起</strong>，即图中的Aliasing，这里便发生了<strong>走样</strong></p>
<h5 id="反走样Antialiasing"><a href="#反走样Antialiasing" class="headerlink" title="反走样Antialiasing"></a>反走样Antialiasing</h5><p>走样发生的原因可总结为<strong>采样的速率慢于被采样对象的变化频率</strong>，在图形成像上的反走样由此可选择路线为</p>
<ul>
<li>增大采样速率<ul>
<li>增加屏幕分辨率</li>
</ul>
</li>
<li>降低被采样对象变化频率<ul>
<li><strong>采样前</strong>过滤掉高频信号</li>
</ul>
</li>
</ul>
<p>前者不必多说，即像素点的增加会减小空间上的采样间隔，对于后者而言如图所示</p>
<p><img src="/2022/05/05/GraphicsNote/02/Graphics02/image-20220331183833935.png" alt="image-20220331183833935"></p>
<p><img src="/2022/05/05/GraphicsNote/02/Graphics02/image-20220331185101874.png" alt="image-20220331185101874"></p>
<p>非常值得注意的一点是：<strong>在采样前进行低通滤波处理</strong>，否则不会得到理想的效果</p>
<p><img src="/2022/05/05/GraphicsNote/02/Graphics02/image-20220331185345747.png" alt="image-20220331185345747"></p>
<p>[^两种情况]: 左侧为Blurred Aliasing，右侧为Antialiasing</p>
<p>原因很好理解，因为对已经发生alias的频谱再使用低通滤波处理，得到的频谱仍有可能是存在alias的，所以模糊掉的只是已经存在的锯齿</p>
<p>对于Pre-Filter的选择多种多样，在此以一个像素大小的Box Filter为例</p>
<p><img src="/2022/05/05/GraphicsNote/02/Graphics02/image-20220331191532805.png" alt="image-20220331191532805"></p>
<p>如图所示，在这一个像素大小的区域中，将根据图形覆盖的面积决定颜色的分布量，不再是最开始的采样结果中的01分布，而是具有过渡的状态</p>
<p>以MSAA为例，将每个像素点的采样点从中心变为N×N的形势，对覆盖点的数量进行颜色插值</p>
<p><img src="/2022/05/05/GraphicsNote/02/Graphics02/image-20220331191909666.png" alt="image-20220331191909666"></p>
<p><img src="/2022/05/05/GraphicsNote/02/Graphics02/image-20220331191928769.png" alt="image-20220331191928769"></p>
<p>虽然图示的采样点仅仅是被简单的划分出来，但在实际应用中会有多种划分方式</p>
<p>反走样，或者在这里更多指的是抗锯齿，的方法有许多种，更多的思路不在此一一解释</p>
<h4 id="深度缓冲-Z-Buffer"><a href="#深度缓冲-Z-Buffer" class="headerlink" title="深度缓冲 Z-Buffer"></a>深度缓冲 Z-Buffer</h4><p>目前为止我们所接触的都是单个图形的光栅化过程，当场景中存在多个物体该如何判断它们的前后关系呢</p>
<p>非常朴素的做法是根据物体的前后关系进行绘制顺序排列，即靠后的物体先绘制，靠前的物体后绘制，这种方法被称为<strong>画家算法</strong></p>
<p><img src="/2022/05/05/GraphicsNote/02/Graphics02/image-20220331202436285.png" alt="image-20220331202436285"></p>
<p>其中的问题不言而喻，对于上图这种部分遮挡又部分被遮挡的情况，该算法无法完成绘制</p>
<p><strong>但我们可以把画家算法的思路从物体转移到像素，或者说是采样点上去，这就是Z-Buffer</strong></p>
<ul>
<li>Z-Buffer算法需要为每个像素点维持一个深度数组记为zbuffer，其每个位置初始值置为无穷大（即离摄像机无穷远）。</li>
<li>随后我们遍历每个三角形面上的每一个像素点[x,y]，如果该像素点的深度值z，小于zbuffer[x,y]中的值，则更新zbuffer[x,y]值为该点深度值z，并同时更新该像素点[x,y]的颜色为该三角形面上的该点的颜色。</li>
</ul>
<p><strong>在接下来的内容中，为了便于理解z将被一直取正值，即值越大意味着离我们的距离越远，虽然在之前z一直是一个负数</strong></p>
<p>至此我们可以得到正确的遮挡关系了，在渲染时，会额外多一张反应z值的深度图</p>
<ul>
<li>frame buffer存储颜色信息</li>
<li>depth buffer（z-buffer）存储深度信息</li>
</ul>
<p><img src="/2022/05/05/GraphicsNote/02/Graphics02/image-20220331203156092.png" alt="image-20220331203156092"></p>
<p>关于Z-Buffer算法的更多解释如下</p>
<p><img src="/2022/05/05/GraphicsNote/02/Graphics02/image-20220331203351837.png" alt="image-20220331203351837"></p>
<p><img src="/2022/05/05/GraphicsNote/02/Graphics02/image-20220331203408085.png" alt="image-20220331203408085"></p>
<p>这个算法的时间复杂度是<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex" xmlns="http://www.w3.org/2000/svg" width="4.844ex" height="2.262ex" role="img" focusable="false" viewbox="0 -750 2141 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D442" d="M740 435Q740 320 676 213T511 42T304 -22Q207 -22 138 35T51 201Q50 209 50 244Q50 346 98 438T227 601Q351 704 476 704Q514 704 524 703Q621 689 680 617T740 435ZM637 476Q637 565 591 615T476 665Q396 665 322 605Q242 542 200 428T157 216Q157 126 200 73T314 19Q404 19 485 98T608 313Q637 408 637 476Z"/></g><g data-mml-node="mo" transform="translate(763,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"/></g><g data-mml-node="mi" transform="translate(1152,0)"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mo" transform="translate(1752,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"/></g></g></g></svg></mjx-container>，因为它仅仅是找出了深度值最小的三角面，并没有进行排序，我们无须担心这一点的计算量很大，你可以相信你的GPU受过特殊训练</p>
<h4 id="作业内容"><a href="#作业内容" class="headerlink" title="作业内容"></a>作业内容</h4><h5 id="任务目标"><a href="#任务目标" class="headerlink" title="任务目标"></a>任务目标</h5><p>在上次作业中，虽然我们在屏幕上画出一个线框三角形，但这看起来并不是那么的有趣。所以这一次我们继续推进一步——在屏幕上画出一个实心三角形，换言之，栅格化一个三角形。</p>
<p>上一次作业中，在视口变化之后，我们调用了函数<code>rasterize_wireframe(const Triangle&amp; t)</code>。但这一次，你需要自己填写并调用函数 <code>rasterize_triangle(const Triangle&amp; t)</code>。</p>
<p>该函数的内部工作流程如下：</p>
<ul>
<li><p>创建三角形的 2 维 bounding box。</p>
</li>
<li><p>遍历此 bounding box 内的所有像素（使用其整数索引）。然后，使用像素中心的屏幕空间坐标来检查中心点是否在三角形内。</p>
</li>
<li><p>如果在内部，则将其位置处的插值深度值 (interpolated depth value) 与深度缓冲区 (depth buffer) 中的相应值进行比较。</p>
</li>
<li><p>如果当前点更靠近相机，请设置像素颜色并更新深度缓冲区 (depth buffer)。你需要修改的函数如下：</p>
<ul>
<li><code>rasterize_triangle(...)</code>: 执行三角形栅格化算法</li>
<li><code>static bool insideTriangle(...)</code>: 测试点是否在三角形内</li>
</ul>
</li>
<li><p>你可以修改此函数的定义，这意味着，你可以按照自己的方式更新返回类型或函数参数。因为我们只知道三角形三个顶点处的深度值，所以对于三角形内部的像素，我们需要用插值的方法得到其深度值。我们已经为你处理好了这一部分，因为有关这方面的内容尚未在课程中涉及。插值的深度值被储存在变量 z_interpolated中。请注意我们是如何初始化 depth buffer 和注意 z values 的符号。为了方便同学们写代码，我们将 z 进行了反转，保证都是正数，并且越大表示离视点越远。在此次作业中，你无需处理旋转变换，只需为模型变换返回一个单位矩阵。最后，我们提供了两个 hard-coded 三角形来测试你的实现，如果程序实现正确，你将看到如下所示的输出图像:</p>
<p><img src="/2022/05/05/GraphicsNote/02/Graphics02/image-20220331211337931.png" alt="image-20220331211337931"></p>
<p><strong>需要注意的是该作业框架中没有补充透视投影变换矩阵函数内容和模型变换矩阵函数内容，这里仅仅需要补充前者</strong></p>
<p><strong>提高内容</strong>：</p>
<p>用 super-sampling 处理 Anti-aliasing :</p>
<p>你可能会注意到，当我们放大图像时，图像边缘会有锯齿感。我们可以用 super-sampling来解决这个问题，即对每个像素进行 2 * 2 采样，并比较前后的结果 (这里并不需要考虑像素与像素间的样本复用)。需要注意的点有，对于像素内的每一个样本都需要维护它自己的深度值，即每一个像素都需要维护一个 sample list。最后，如果你实现正确的话，你得到的三角形不应该有不正常的黑边。</p>
</li>
</ul>
<h5 id="代码解释"><a href="#代码解释" class="headerlink" title="代码解释"></a>代码解释</h5><p><strong>使用以下代码并不会得到与作业图完全相同的结果，因为这次的框架内容并没有让z保持正值</strong></p>
<p>若想得到相同的结果，请在将摄像机以Z轴旋转180°</p>
<p>判断在三角形内部的采样点</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">bool</span> <span class="hljs-title">insideTriangle</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y, <span class="hljs-type">const</span> Vector3f* _v)</span></span><br><span class="hljs-function"></span>{<br>    <span class="hljs-comment">// TODO : Implement this function to check if the point (x, y) is inside the triangle represented by _v[0], _v[1], _v[2]</span><br><br>    <span class="hljs-comment">//测试点的坐标为(x, y)</span><br>    <span class="hljs-comment">//三角形三点的坐标分别为_v[0], _v[1], _v[2]</span><br><br>    <span class="hljs-comment">//叉乘公式为(x1, y1)X(x2, y2) = x1*y2 - y1*x2</span><br><br>    <span class="hljs-comment">//（1）准备三角形各边的的向量</span><br>    Eigen::Vector2f side1;<br>    side1 &lt;&lt; _v[<span class="hljs-number">1</span>].<span class="hljs-built_in">x</span>() - _v[<span class="hljs-number">0</span>].<span class="hljs-built_in">x</span>(), _v[<span class="hljs-number">1</span>].<span class="hljs-built_in">y</span>() - _v[<span class="hljs-number">0</span>].<span class="hljs-built_in">y</span>();<br>    Eigen::Vector2f side2;<br>    side2 &lt;&lt; _v[<span class="hljs-number">2</span>].<span class="hljs-built_in">x</span>() - _v[<span class="hljs-number">1</span>].<span class="hljs-built_in">x</span>(), _v[<span class="hljs-number">2</span>].<span class="hljs-built_in">y</span>() - _v[<span class="hljs-number">1</span>].<span class="hljs-built_in">y</span>();<br>    Eigen::Vector2f side3;<br>    side3 &lt;&lt; _v[<span class="hljs-number">0</span>].<span class="hljs-built_in">x</span>() - _v[<span class="hljs-number">2</span>].<span class="hljs-built_in">x</span>(), _v[<span class="hljs-number">0</span>].<span class="hljs-built_in">y</span>() - _v[<span class="hljs-number">2</span>].<span class="hljs-built_in">y</span>();<br><br>    <span class="hljs-comment">//（2）准备测量点和三角形各点连线的向量</span><br>    Eigen::Vector2f v1;<br>    v1 &lt;&lt; x - _v[<span class="hljs-number">0</span>].<span class="hljs-built_in">x</span>(), y - _v[<span class="hljs-number">0</span>].<span class="hljs-built_in">y</span>();<br>    Eigen::Vector2f v2;<br>    v2 &lt;&lt; x - _v[<span class="hljs-number">1</span>].<span class="hljs-built_in">x</span>(), y - _v[<span class="hljs-number">1</span>].<span class="hljs-built_in">y</span>();<br>    Eigen::Vector2f v3;<br>    v3 &lt;&lt; x - _v[<span class="hljs-number">2</span>].<span class="hljs-built_in">x</span>(), y - _v[<span class="hljs-number">2</span>].<span class="hljs-built_in">y</span>();<br><br>    <span class="hljs-comment">//（3）三角形各边的的向量叉乘测量点和三角形各点连线的向量</span><br>    <span class="hljs-type">float</span> z1 = side1.<span class="hljs-built_in">x</span>() * v1.<span class="hljs-built_in">y</span>() - side1.<span class="hljs-built_in">y</span>() * v1.<span class="hljs-built_in">x</span>();<br>    <span class="hljs-type">float</span> z2 = side2.<span class="hljs-built_in">x</span>() * v2.<span class="hljs-built_in">y</span>() - side2.<span class="hljs-built_in">y</span>() * v2.<span class="hljs-built_in">x</span>();<br>    <span class="hljs-type">float</span> z3 = side3.<span class="hljs-built_in">x</span>() * v3.<span class="hljs-built_in">y</span>() - side3.<span class="hljs-built_in">y</span>() * v3.<span class="hljs-built_in">x</span>();<br><br>    <span class="hljs-comment">//（4）判断叉乘结果是否有相同的符号</span><br>    <span class="hljs-keyword">if</span> ((z1 &gt; <span class="hljs-number">0</span> &amp;&amp; z2 &gt; <span class="hljs-number">0</span> &amp;&amp; z3 &gt; <span class="hljs-number">0</span>) || (z1 &lt; <span class="hljs-number">0</span> &amp;&amp; z2 &lt; <span class="hljs-number">0</span> &amp;&amp; z3 &lt; <span class="hljs-number">0</span>))<br>    {<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    }<br>    <span class="hljs-keyword">else</span><br>    {<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    }<br>}<br></code></pre></td></tr></table></figure>

<p>或者是另一种简化版本</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">bool</span> <span class="hljs-title">insideTriangle</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y, <span class="hljs-type">const</span> Vector3f* _v, <span class="hljs-type">int</span>)</span></span><br><span class="hljs-function"></span>{<br>    <span class="hljs-function">Vector2f <span class="hljs-title">point</span><span class="hljs-params">(x, y)</span></span>;<br>    <span class="hljs-comment">//A-0 B-1 C-2</span><br>    <span class="hljs-comment">//_v中存储的是三角形的三个顶点的三维坐标，使用.head取其x与y进行判断即可</span><br>    Vector2f AB = _v[<span class="hljs-number">1</span>].<span class="hljs-built_in">head</span>(<span class="hljs-number">2</span>) - _v[<span class="hljs-number">0</span>].<span class="hljs-built_in">head</span>(<span class="hljs-number">2</span>);<br>    Vector2f BC = _v[<span class="hljs-number">2</span>].<span class="hljs-built_in">head</span>(<span class="hljs-number">2</span>) - _v[<span class="hljs-number">1</span>].<span class="hljs-built_in">head</span>(<span class="hljs-number">2</span>);<br>    Vector2f CA = _v[<span class="hljs-number">0</span>].<span class="hljs-built_in">head</span>(<span class="hljs-number">2</span>) - _v[<span class="hljs-number">2</span>].<span class="hljs-built_in">head</span>(<span class="hljs-number">2</span>);<br><br>    Vector2f AP = point - _v[<span class="hljs-number">0</span>].<span class="hljs-built_in">head</span>(<span class="hljs-number">2</span>);<br>    Vector2f BP = point - _v[<span class="hljs-number">1</span>].<span class="hljs-built_in">head</span>(<span class="hljs-number">2</span>);<br>    Vector2f CP = point - _v[<span class="hljs-number">2</span>].<span class="hljs-built_in">head</span>(<span class="hljs-number">2</span>);<br><br>    <span class="hljs-keyword">return</span> AB[<span class="hljs-number">0</span>] * AP[<span class="hljs-number">1</span>] - AB[<span class="hljs-number">1</span>] * AP[<span class="hljs-number">0</span>] &gt; <span class="hljs-number">0</span><br>        &amp;&amp; BC[<span class="hljs-number">0</span>] * BP[<span class="hljs-number">1</span>] - BC[<span class="hljs-number">1</span>] * BP[<span class="hljs-number">0</span>] &gt; <span class="hljs-number">0</span><br>        &amp;&amp; CA[<span class="hljs-number">0</span>] * CP[<span class="hljs-number">1</span>] - CA[<span class="hljs-number">1</span>] * CP[<span class="hljs-number">0</span>] &gt; <span class="hljs-number">0</span><br>        ||<br>        AB[<span class="hljs-number">0</span>] * AP[<span class="hljs-number">1</span>] - AB[<span class="hljs-number">1</span>] * AP[<span class="hljs-number">0</span>] &lt; <span class="hljs-number">0</span><br>        &amp;&amp; BC[<span class="hljs-number">0</span>] * BP[<span class="hljs-number">1</span>] - BC[<span class="hljs-number">1</span>] * BP[<span class="hljs-number">0</span>] &lt; <span class="hljs-number">0</span><br>        &amp;&amp; CA[<span class="hljs-number">0</span>] * CP[<span class="hljs-number">1</span>] - CA[<span class="hljs-number">1</span>] * CP[<span class="hljs-number">0</span>] &lt; <span class="hljs-number">0</span>;<br>}<br></code></pre></td></tr></table></figure>

<p>三角形的光栅化</p>
<p><strong>框架注释中给出的深度插值的部分，需要使用c++17标准</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">void</span> rst::rasterizer::<span class="hljs-built_in">rasterize_triangle</span>(<span class="hljs-type">const</span> Triangle&amp; t) <br>{<br>    <span class="hljs-comment">//执行三角形栅格化算法</span><br>    <span class="hljs-keyword">auto</span> v = t.<span class="hljs-built_in">toVector4</span>();<br>    <span class="hljs-comment">//f12进入toVector4()处后可以发现返回值是array&lt;Vector4f, 3&gt;</span><br>    <span class="hljs-comment">//我的理解：v是一个包含三个顶点信息的数组，每个顶点坐标用Vector4f（齐次坐标）表示</span><br>    <span class="hljs-comment">// TODO : Find out the bounding box of current triangle.</span><br>    <span class="hljs-comment">// iterate through the pixel and find if the current pixel is inside the triangle</span><br><br>    <span class="hljs-comment">//（1）用矩形将三角形包围起来,找到矩形的四个顶点，构建三角形包围盒</span><br>    <span class="hljs-type">float</span> min_x = std::<span class="hljs-built_in">floor</span>(std::<span class="hljs-built_in">min</span>(v[<span class="hljs-number">0</span>].<span class="hljs-built_in">x</span>(), std::<span class="hljs-built_in">min</span>(v[<span class="hljs-number">1</span>].<span class="hljs-built_in">x</span>(), v[<span class="hljs-number">2</span>].<span class="hljs-built_in">x</span>())));<br>    <span class="hljs-type">float</span> max_x = std::<span class="hljs-built_in">ceil</span>(std::<span class="hljs-built_in">max</span>(v[<span class="hljs-number">0</span>].<span class="hljs-built_in">x</span>(), std::<span class="hljs-built_in">max</span>(v[<span class="hljs-number">1</span>].<span class="hljs-built_in">x</span>(), v[<span class="hljs-number">2</span>].<span class="hljs-built_in">x</span>())));<br>    <span class="hljs-type">float</span> min_y = std::<span class="hljs-built_in">floor</span>(std::<span class="hljs-built_in">min</span>(v[<span class="hljs-number">0</span>].<span class="hljs-built_in">y</span>(), std::<span class="hljs-built_in">min</span>(v[<span class="hljs-number">1</span>].<span class="hljs-built_in">y</span>(), v[<span class="hljs-number">2</span>].<span class="hljs-built_in">y</span>())));<br>    <span class="hljs-type">float</span> max_y = std::<span class="hljs-built_in">ceil</span>(std::<span class="hljs-built_in">max</span>(v[<span class="hljs-number">0</span>].<span class="hljs-built_in">y</span>(), std::<span class="hljs-built_in">max</span>(v[<span class="hljs-number">1</span>].<span class="hljs-built_in">y</span>(), v[<span class="hljs-number">2</span>].<span class="hljs-built_in">y</span>())));<br><br>    <span class="hljs-comment">//（2）遍历三角形包围盒中的所有测试点</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> x = min_x; x &lt;= max_x; x++)<br>    {<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> y = min_y; y &lt;= max_y; y++)<br>        {<br>            <span class="hljs-comment">// If so, use the following code to get the interpolated z value.</span><br>            <span class="hljs-comment">//auto[alpha, beta, gamma] = computeBarycentric2D(x, y, t.v);</span><br>            <span class="hljs-comment">//float w_reciprocal = 1.0/(alpha / v[0].w() + beta / v[1].w() + gamma / v[2].w());</span><br>            <span class="hljs-comment">//float z_interpolated = alpha * v[0].z() / v[0].w() + beta * v[1].z() / v[1].w() + gamma * v[2].z() / v[2].w();</span><br>            <span class="hljs-comment">//z_interpolated *= w_reciprocal;</span><br><br>            <span class="hljs-comment">// TODO : set the current pixel (use the set_pixel function) to the color of the triangle (use getColor function) if it should be painted.</span><br><br>            <span class="hljs-comment">//判断是否在三角形内,如果在内部，则将其位置处的插值深度值 (interpolated depth value) 与深度缓冲区 (depth buffer) 中的相应值进行比较。</span><br>            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">insideTriangle</span>(x, y, t.v))<br>            {<br>                <span class="hljs-comment">//以下是计算插值的内容，暂时看不懂,先抄别人博客补全</span><br>                <span class="hljs-comment">//最小深度，默认是无穷远</span><br>                <span class="hljs-type">float</span> min_depth = FLT_MAX;<br><br>                <span class="hljs-comment">//如果在三角形内部，计算当前深度,得到当前最小深度</span><br>                <span class="hljs-keyword">auto</span> tup = <span class="hljs-built_in">computeBarycentric2D</span>(x + <span class="hljs-number">0.5</span>, y + <span class="hljs-number">0.5</span>, t.v);<br><br>                <span class="hljs-type">float</span> alpha, beta, gamma;<br>                std::<span class="hljs-built_in">tie</span>(alpha, beta, gamma) = tup;<br>                <span class="hljs-type">float</span> w_reciprocal = <span class="hljs-number">1.0</span> / (alpha / v[<span class="hljs-number">0</span>].<span class="hljs-built_in">w</span>() + beta / v[<span class="hljs-number">1</span>].<span class="hljs-built_in">w</span>() + gamma / v[<span class="hljs-number">2</span>].<span class="hljs-built_in">w</span>());<br>                <span class="hljs-type">float</span> z_interpolated = alpha * v[<span class="hljs-number">0</span>].<span class="hljs-built_in">z</span>() / v[<span class="hljs-number">0</span>].<span class="hljs-built_in">w</span>() + beta * v[<span class="hljs-number">1</span>].<span class="hljs-built_in">z</span>() / v[<span class="hljs-number">1</span>].<span class="hljs-built_in">w</span>() + gamma * v[<span class="hljs-number">2</span>].<span class="hljs-built_in">z</span>() / v[<span class="hljs-number">2</span>].<span class="hljs-built_in">w</span>();<br>                z_interpolated *= w_reciprocal;<br>                min_depth = std::<span class="hljs-built_in">min</span>(min_depth, z_interpolated);<br><br>                <span class="hljs-comment">//如果x,y所在点的深度小于z-buffer的深度，</span><br>                <span class="hljs-keyword">if</span> (depth_buf[<span class="hljs-built_in">get_index</span>(x, y)] &gt; min_depth)<br>                {<br>                    <span class="hljs-comment">//获得最上层应该渲染的颜色</span><br>                    Vector3f color = t.<span class="hljs-built_in">getColor</span>();<br>                    Vector3f point;<br>                    point &lt;&lt; x, y, min_depth;<br>                    <span class="hljs-comment">//更新深度</span><br>                    depth_buf[<span class="hljs-built_in">get_index</span>(x, y)] = min_depth;<br>                    <span class="hljs-comment">//更新所在点的颜色</span><br>                    <span class="hljs-built_in">set_pixel</span>(point, color);<br>                }<br>            }<br>        }<br>    }<br>}<br></code></pre></td></tr></table></figure>

<p>提高部分</p>
<p>在上个函数（1）后加入以下部分</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">//MSAA 2*2</span><br>std::vector&lt;Vector2f&gt; multSample<br>{<br>    { <span class="hljs-number">0.25</span>, <span class="hljs-number">0.75</span> },<br>    { <span class="hljs-number">0.75</span>, <span class="hljs-number">0.75</span> },<br>    { <span class="hljs-number">0.25</span>, <span class="hljs-number">0.25</span> },<br>    { <span class="hljs-number">0.75</span>, <span class="hljs-number">0.25</span> }<br>};<br><br> <span class="hljs-type">int</span> count = <span class="hljs-number">0</span>;<br> <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">4</span>; i++)<br> {<br>     <span class="hljs-keyword">if</span> (<span class="hljs-built_in">insideTriangle</span>(x + multSample[i].<span class="hljs-built_in">x</span>(), y + multSample[i].<span class="hljs-built_in">y</span>(), t.v))<br>     {<br>     	count++;<br>     }<br> }<br></code></pre></td></tr></table></figure>

<p>并将原有的<code>if (insideTriangle(x, y, t.v))</code>改为<code>if (count)</code></p>
<p>将颜色信息从<code>Vector3f color = t.getColor()</code>修改为<code>Vector3f color = t.getColor() * (count / 4.0)</code></p>
<div id="paginator"></div></div><div id="post-footer"><div id="pages"><div id="footer-link" style="right: calc(50% - 1px);order: 1;border-right: 1px solid #fe2;padding-left: unset;max-width: calc(50% - 4px);"><a href="/2022/05/06/%E7%AE%97%E6%B3%95/%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F/">← Next 基数排序</a></div><div id="footer-link" style="left: 50%;order: 0;border-left: 1px solid #fe2;padding-right: unset;max-width: calc(50% - 5px);"><a href="/2022/05/05/GraphicsNote/00/Graphics00/">计算机图形学基础-课程简介 Prev →</a></div></div></div><details id="reward"><summary>打赏</summary><div id="alipay"><span>支付宝 | Alipay</span><br><img src="/img/Alipay.png"></div><div id="wechat"><span>微信 | WeChat</span><br><img src="/img/WeChat.png"></div></details></div><div id="bottom-btn"><a id="to-top" onClick="index.scrolltop();" title="to top" style="opacity: 0; display: none;">∧</a></div></article><div class="aside-box"><aside><div id="aside-top"><div id="about"><a href="/" id="logo"><img src="https://ak.hypergryph.com/assets/index/images/ak/pc/faction/1.png" alt="Logo"></a><h1 id="Dr"><a href="about/">Xenon</a></h1><div id="description"><p>Just a blog.</p></div><!--if page.published === undefined--><section id="total"><a id="total-archives" href="/archives"><span class="total-title">Archives Total:</span><span class="total-number">8</span></a><div id="total-tags"><span class="total-title">Tags:</span><span class="total-number">11</span></div><div id="total-categories"><span class="total-title">Categories:</span><span class="total-number">3</span></div></section></div><div id="aside-block"><div id="toc-div"><h1>INDEX</h1><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8"><span class="toc-number">1.</span> <span class="toc-text">现代计算机图形学基础入门</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%89%E6%A0%85%E5%8C%96%E6%88%90%E5%83%8F"><span class="toc-number">1.1.</span> <span class="toc-text">光栅化成像</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%89%E6%A0%85%E5%8C%96"><span class="toc-number">1.1.1.</span> <span class="toc-text">光栅化</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%89%E8%A7%92%E5%BD%A2%E7%9A%84%E5%85%89%E6%A0%85%E5%8C%96"><span class="toc-number">1.1.1.1.</span> <span class="toc-text">三角形的光栅化</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%A6%BB%E6%95%A3%E5%8C%96%E4%B8%89%E8%A7%92%E5%BD%A2"><span class="toc-number">1.1.1.1.1.</span> <span class="toc-text">离散化三角形</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%86%85%E4%B8%8E%E5%A4%96"><span class="toc-number">1.1.1.1.2.</span> <span class="toc-text">内与外</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%BE%B9%E7%95%8C%E6%83%85%E5%86%B5"><span class="toc-number">1.1.1.1.3.</span> <span class="toc-text">边界情况</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BC%98%E5%8C%96%E6%96%B9%E6%B3%95"><span class="toc-number">1.1.1.1.4.</span> <span class="toc-text">优化方法</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B5%B0%E6%A0%B7%E4%B8%8E%E5%8F%8D%E8%B5%B0%E6%A0%B7"><span class="toc-number">1.1.1.2.</span> <span class="toc-text">走样与反走样</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%B5%B0%E6%A0%B7-Aliasing"><span class="toc-number">1.1.1.2.1.</span> <span class="toc-text">走样 Aliasing</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%87%87%E6%A0%B7-Sample"><span class="toc-number">1.1.1.2.2.</span> <span class="toc-text">采样 Sample</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%BB%A4%E6%B3%A2-Filtering"><span class="toc-number">1.1.1.2.2.1.</span> <span class="toc-text">滤波 Filtering</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%8D%B7%E7%A7%AF-Convolution"><span class="toc-number">1.1.1.2.2.2.</span> <span class="toc-text">卷积 Convolution</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%BB%A4%E6%B3%A2%E5%99%A8-Filter"><span class="toc-number">1.1.1.2.2.3.</span> <span class="toc-text">滤波器 Filter</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%97%B6%E5%9F%9F-Spatial-Domain%E4%B8%8E%E9%A2%91%E5%9F%9F-Frequency-Domain%E4%B8%8A%E7%9A%84%E9%87%87%E6%A0%B7"><span class="toc-number">1.1.1.2.2.4.</span> <span class="toc-text">时域 Spatial Domain与频域 Frequency Domain上的采样</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8F%8D%E8%B5%B0%E6%A0%B7Antialiasing"><span class="toc-number">1.1.1.2.3.</span> <span class="toc-text">反走样Antialiasing</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B7%B1%E5%BA%A6%E7%BC%93%E5%86%B2-Z-Buffer"><span class="toc-number">1.1.1.3.</span> <span class="toc-text">深度缓冲 Z-Buffer</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%9C%E4%B8%9A%E5%86%85%E5%AE%B9"><span class="toc-number">1.1.1.4.</span> <span class="toc-text">作业内容</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%BB%E5%8A%A1%E7%9B%AE%E6%A0%87"><span class="toc-number">1.1.1.4.1.</span> <span class="toc-text">任务目标</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E8%A7%A3%E9%87%8A"><span class="toc-number">1.1.1.4.2.</span> <span class="toc-text">代码解释</span></a></li></ol></li></ol></li></ol></li></ol></li></ol></div></div></div><footer><nobr><span class="text-title">©</span><span class="text-content">1970 to 2020</span></nobr><br><nobr><span class="text-title">ICP</span><span class="text-content">——备案号——</span></nobr><br><text>published with <a target="_blank" rel="noopener" href="http://hexo.io">Hexo</a></text><text> Theme <a target="_blank" rel="noopener" href="https://github.com/Yue-plus/hexo-theme-arknights">Arknight</a></text><wbr><text>by <a target="_blank" rel="noopener" href="https://github.com/Yue-plus">Yue_plus</a></text></footer></aside></div></main><canvas id="canvas-dust"></canvas><script src="/js/search.js"></script><script>const reset=_=>{}</script><script src="//unpkg.com/@highlightjs/cdn-assets@11.4.0/highlight.min.js"></script><script src="/js/arknights.js"></script><script>document.addEventListener("load",reset())</script></body></html>