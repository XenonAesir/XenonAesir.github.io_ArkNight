<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><title>光栅化成像-视图变换 | Hexo</title><script>var config = {"hostname":"http://example.com","root":"/","preload":false,"path":""}</script><link rel="stylesheet" href="/css/arknights.css"><link rel="stylesheet" href="//unpkg.com/@highlightjs/cdn-assets@11.4.0/styles/atom-one-dark-reasonable.min.css"><style>@font-face {
 font-family: BenderLight;
 src: local('Bender'), url("/font/BenderLight.ttf");
}
@font-face {
 font-family: 'JetBrains Mono';
 src: local('JetBrains Mono'), url('/font/JetBrainsMono-Regular.woff2') format('woff2');
}</style><meta name="generator" content="Hexo 6.1.0"></head><body style="background-image:url(https://ak.hypergryph.com/assets/index/images/ak/pc/bk.jpg);"><div id="cursor-container"><div id="cursor-outer"></div><div id="cursor-effect"></div></div><main><header><nav><div class="navBtn"><i class="navBtnIcon"><span class="navBtnIconBar"></span><span class="navBtnIconBar"></span><span class="navBtnIconBar"></span></i></div><ol class="navContent"><li class="navItem search-header"><input autocomplete="off" autocorrect="off" autocapitalize="none" placeholder="数据检索" spellcheck="false" maxlength="50" type="text" id="search-input"></li><li class="navItem"><a href="/"><span class="navItemTitle">Home</span></a></li><li class="navItem"><a href="/archives/"><span class="navItemTitle">Archives</span></a></li></ol></nav><div class="search-popup"><div id="search-result"></div></div></header><article><div id="post-bg"><div id="post-title"><h1>光栅化成像-视图变换</h1><div id="post-info"><span>First Post:<span class="control"><time datetime="2022-05-05T15:58:18.000Z" id="date"> 2022-05-05</time></span></span><br><span>Last Update:<span class="control"><time datetime="2022-05-05T18:19:06.695Z" id="updated"> 2022-05-06</time></span></span></div></div><hr><div id="post-content"><h1 id="现代计算机图形学基础入门"><a href="#现代计算机图形学基础入门" class="headerlink" title="现代计算机图形学基础入门"></a>现代计算机图形学基础入门</h1><h2 id="光栅化成像"><a href="#光栅化成像" class="headerlink" title="光栅化成像"></a>光栅化成像</h2><h3 id="视图变换"><a href="#视图变换" class="headerlink" title="视图变换"></a>视图变换</h3><p>本节内容附加参考资料：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://www.bilibili.com/read/cv11967054">图形学随笔：MVP变换—视图变换 - 哔哩哔哩 (bilibili.com)</a></li>
<li><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/357440509">MVP 矩阵变换 - 知乎 (zhihu.com)</a></li>
</ul>
<p>我们可以这样来描述视图变换的任务：将虚拟世界中以（x,y,z)为坐标的物体变换到 以一个个像素位置(x,y) 来表示的屏幕坐标系之中(2维)，这确实是一个较为复杂的过程，但是整个过程可以被细分为如下几个步骤：</p>
<ul>
<li>模型变换<ul>
<li>这一步的目的是将虚拟世界中或者更具体点，游戏场景中的物体调整至他们应该在的位置</li>
</ul>
</li>
<li>摄像机变换<ul>
<li>在游戏中我们真正在乎的是摄像机(或者说眼睛)所看到的东西，也就是需要得到物体与摄像机的相对位置</li>
</ul>
</li>
<li>投影变换<ul>
<li>在摄像机变换之后，我们得到了所有可视范围内的物体相对于摄像机的相对位置坐标(x,y,z)，之后根据具体情况选择平行投影或是透视投影，将三维空间投影至标准二维平面([-1,1]^2)之上 （tips：这里的z并没有丢掉，为了之后的遮挡关系检测）</li>
</ul>
</li>
<li>视口变换<ul>
<li>将处于标准平面映射到屏幕分辨率范围之内，即[-1,1]^2 -&gt; [0,width]*[0,height]其中width和height指屏幕分辨率大小</li>
</ul>
</li>
</ul>
<p><img src="/2022/05/05/GraphicsNote/01/Graphics01/v2-30da233abacca39a4cf87c28ed8e3e75_720w-16484488964933.jpg" alt="img"></p>
<p>值得一提的是，以上名词的英文名词较为混乱，简要关系如下：</p>
<ul>
<li><p><strong>视图变换（Viewing Transformation）</strong></p>
<ul>
<li><p><strong>模型变换(modeling transformation)</strong></p>
</li>
<li><p><strong>摄像机变换(camera transformation)&#x2F;视角变换(view transformation)</strong></p>
</li>
<li><p><strong>投影变换(projection transformation)</strong></p>
</li>
<li><p><strong>视口变换(viewport transformation)</strong></p>
</li>
</ul>
</li>
</ul>
<p>于是模型变换(M)、视角变换(V)、投影变换(P)的统称为<strong>MVP变换</strong>，在此名词中视口变换将被孤立</p>
<p><strong>并且在此之后将会有越来越多的英文名词</strong></p>
<h4 id="模型变换-M"><a href="#模型变换-M" class="headerlink" title="模型变换 M"></a>模型变换 M</h4><p>关于模型变换其实在开头部分便已经讲清楚了，就是利用基础的变换矩阵将世界当中的物体调整至我们想要的地方(旋转，平移，缩放)。</p>
<p><img src="/2022/05/05/GraphicsNote/01/Graphics01/image-20220328164058196-16484568603951.png" alt="image-20220328164058196"></p>
<p>[^M矩阵求法]: 按照 <strong>缩放——旋转——平移</strong> 的顺序进行矩阵变换，因为这种结果是我们需要的</p>
<h4 id="摄像机变换-V"><a href="#摄像机变换-V" class="headerlink" title="摄像机变换 V"></a>摄像机变换 V</h4><p>由于摄像机的变换是在世界空间中先旋转后平移得到的，所以需要先反向进行平移变换，再反向进行旋转变换。</p>
<p><strong>摄像机定义</strong>：视图变换需要对摄像机生成的视图有一个唯一的定义，摄像机定义包含三个要素：</p>
<ul>
<li><strong>位置</strong>，用向量 e 表示：显然，一个物体在空间中，肯定是需要一个坐标的；</li>
<li><strong>朝向</strong>，用向量 g 表示：有了位置后，摄像机不同的拍摄角度会生成不同的视图，所以还要定义一个朝向；</li>
<li><strong>向上的方向</strong>，用向量 t 表示：固定好位置与朝向之后，摄像机还是可以360°旋转的，不同的旋转角也会生成不同的视图，所以还需要定义一个向上的方向来描述摄像机的旋转。</li>
</ul>
<p>由此定义出相对摄像机的坐标系：</p>
<p><img src="/2022/05/05/GraphicsNote/01/Graphics01/v2-b2379690a91c749d08822b9e1a76fbdb_720w-16484572053383.jpg" alt="img"></p>
<p><img src="/2022/05/05/GraphicsNote/01/Graphics01/v2-52b293df688294aa1d1ddbfc20428f38_720w.jpg" alt="img"></p>
<p> <strong>摄像机标准位置</strong>：如果摄像机和场景的模型，都一起以同一个方式运动，那生成的视图也是一样的，由于生成的视图依赖于摄像机的位置、朝向和其自身的旋转，这样场景中的模型和摄像机之间的相对运动关系就复杂起来了</p>
<p>为了简化处理，考虑将摄像机变换到一个约定俗成的位置，变换过程大致为</p>
<ul>
<li>先将摄像机平移至原点</li>
<li>旋转 g 轴到 -z 轴</li>
<li>再旋转 t 轴到 y 轴</li>
<li>最后将 g x t 旋转到 x 轴</li>
</ul>
<p>同时这个变换过程在场景中的所有模型也同步进行。约定摄像机标准位置如下：</p>
<ul>
<li><p>位置在原点，e(0,0,0)；</p>
</li>
<li><p>朝向坐标轴 -z 轴方向，g &#x3D; -z；</p>
</li>
<li><p>向上的方向是 y 轴方向，t &#x3D; y；</p>
</li>
<li><p>场景中模型的变换都围绕原点的摄像机进行；</p>
</li>
</ul>
<p><strong>总结得出，需要将物体与摄像机一同移动到坐标原点，再进行旋转操作使得摄像机的相对坐标与世界坐标重合</strong></p>
<p><img src="/2022/05/05/GraphicsNote/01/Graphics01/image-20220328165227730.png" alt="image-20220328165227730"></p>
<p>对于平移矩阵T容易得出，归为至原点即可</p>
<p><img src="/2022/05/05/GraphicsNote/01/Graphics01/4807bc905cbd74c10a470965347ee634e4ad6288.png@830w_156h_progressive.webp" alt="img"></p>
<p>对于旋转矩阵R，可利用<strong>旋转矩阵是正交矩阵</strong>的性质，求出<strong>由世界坐标旋转至摄像机相对坐标的旋转矩阵</strong>后，<strong>转置</strong>后得到我们需要的旋转矩阵</p>
<p><img src="/2022/05/05/GraphicsNote/01/Graphics01/075b33e61bccd180d215e201427cf6e9c766df4d.png@830w_531h_progressive.webp" alt="img"></p>
<p>由此可得出摄像机变换矩阵为</p>
<p><img src="/2022/05/05/GraphicsNote/01/Graphics01/eca7ffe6b328009deabbfbe6677532b0431d5043.png@830w_218h_progressive.webp" alt="img"></p>
<h4 id="投影变换-P"><a href="#投影变换-P" class="headerlink" title="投影变换 P"></a>投影变换 P</h4><p>在经过摄像机变换之后得到的依然是三维空间中的顶点坐标，那么如何将其映射至二维空间坐标就交给投影变换完成了，在此分为<strong>正交（Orthographic）投影</strong>与<strong>透视（Perspective）投影</strong></p>
<p><img src="/2022/05/05/GraphicsNote/01/Graphics01/v2-9eb78358706fb90876fd2f6831d61454_720w.jpg" alt="img"></p>
<h5 id="正交投影-Perspective"><a href="#正交投影-Perspective" class="headerlink" title="正交投影 Perspective"></a>正交投影 Perspective</h5><p>设摄像机距离近裁剪平面的距离为$near$，距离远裁剪平面的距离为$far$，横纵比为$Aspect$，视锥体半高为$size$，则正交矩阵需要做的是</p>
<p><img src="/2022/05/05/GraphicsNote/01/Graphics01/image-20220328173641763.png" alt="image-20220328173641763"></p>
<p>[^[-1, 1]是什么]: 这是每一项的界，这里是将一个物体压缩或者填充到一个中心点在世界坐标原点的立方体中去，这么做的目的是为了计算方便而已，后面会转变会原来的尺寸</p>
<p>具体实现如图所示，即<strong>先将物体平移至坐标原点，之后进行缩放满足要求</strong></p>
<p><img src="/2022/05/05/GraphicsNote/01/Graphics01/image-20220328224546007.png" alt="image-20220328224546007"></p>
<p>其中字母的含义为：</p>
<p><img src="/2022/05/05/GraphicsNote/01/Graphics01/v2-04e5930ac6d82713fff7d610bcb4682e_720w.jpg" alt="img"></p>
<p>将两者结合可见到这种形式的正交投影矩阵</p>
<p><img src="/2022/05/05/GraphicsNote/01/Graphics01/v2-2d702e8622fba68e4e3803237ec9e706_720w.jpg" alt="img"></p>
<h5 id="透视投影-Orthographic"><a href="#透视投影-Orthographic" class="headerlink" title="透视投影 Orthographic"></a>透视投影 Orthographic</h5><p>透视投影就是最类似人眼所看东西的方式，遵循近大远小，如果说正交投影都是水平光线，那么透视投影则显然不是了</p>
<p>对应的一点$(x, y, z)$投影后对应的坐标为$(x’, y’, z’)$</p>
<p><img src="/2022/05/05/GraphicsNote/01/Graphics01/v2-1bc88c0f6d01fdcdfe32ae3d51f585b4_720w.jpg" alt="img"></p>
<p>于是一个点经过了这样的一个变换过程被投影到了屏幕</p>
<p><img src="/2022/05/05/GraphicsNote/01/Graphics01/image-20220328232059501.png" alt="image-20220328232059501"></p>
<p>所以这个矩阵应该满足</p>
<p><img src="/2022/05/05/GraphicsNote/01/Graphics01/image-20220328232202214.png" alt="image-20220328232202214"></p>
<p>为什么第三列一直未知呢，因为这样的平面分析中，本没有Z的坐标信息，但我们可以推导确定出来</p>
<p>透视投影有两个性质：</p>
<ul>
<li>近裁剪平面上的点不会变化</li>
<li>远裁剪平面的点Z轴信息不会变化</li>
</ul>
<p>所以不妨设第三行为$(0,0,A,B)$利用两点性质分别代入远近平面的任意两点就可以列出两个等式</p>
<p><strong>近裁剪平面上的点不会变化</strong></p>
<p><img src="/2022/05/05/GraphicsNote/01/Graphics01/image-20220328232955940.png" alt="image-20220328232955940"></p>
<p>则可知</p>
<p><img src="/2022/05/05/GraphicsNote/01/Graphics01/image-20220328233026037.png" alt="image-20220328233026037"></p>
<p>将其化为多项式即</p>
<p><img src="/2022/05/05/GraphicsNote/01/Graphics01/image-20220328233721789.png" alt="image-20220328233721789"></p>
<p><strong>远裁剪平面的点Z轴信息不会变化</strong></p>
<p>同理可得出</p>
<p><img src="/2022/05/05/GraphicsNote/01/Graphics01/image-20220328233753690.png" alt="image-20220328233753690"></p>
<p>二者联立解出</p>
<p><img src="/2022/05/05/GraphicsNote/01/Graphics01/image-20220328233828242.png" alt="image-20220328233828242"></p>
<p>所以透视投影的变化矩阵为</p>
<p><img src="/2022/05/05/GraphicsNote/01/Graphics01/v2-6fb3460df4352466c0a5e6df92190e87_720w.jpg" alt="img"></p>
<p>当然这不是完全的透视投影，还需要将其重新正交投影成标准小立方体，故透视投影变化定义为</p>
<p><img src="/2022/05/05/GraphicsNote/01/Graphics01/image-20220328234032478.png" alt="image-20220328234032478"></p>
<p>总和在一起为</p>
<p><img src="/2022/05/05/GraphicsNote/01/Graphics01/v2-f7dfa75940aee675599d1ddbca73ed63_720w.jpg" alt="img"></p>
<h4 id="视口变化-Vp"><a href="#视口变化-Vp" class="headerlink" title="视口变化 Vp"></a>视口变化 Vp</h4><p>上一节中一个物体经过了<strong>MVP变换</strong>后已经被压缩成了一个正则化立方体（Canonical Cube），现在我们需要把它显示到<strong>屏幕</strong>上了</p>
<p>屏幕：</p>
<ul>
<li>像素的集合</li>
<li>分辨率即是像素的数量</li>
<li>典型的光栅化显示载体</li>
</ul>
<p>像素：</p>
<p><img src="/2022/05/05/GraphicsNote/01/Graphics01/image-20220329190351697.png" alt="image-20220329190351697"></p>
<p><img src="/2022/05/05/GraphicsNote/01/Graphics01/image-20220329190153612.png" alt="image-20220329190153612"></p>
<p>[^蓝色的像素]: 并不是指将Canonical Cube单独显示在那一点，仅仅是用了同一张图</p>
<p>这一步十分简单，仅仅是把得到的正则化立方体重新缩放回需要的尺寸</p>
<p><img src="/2022/05/05/GraphicsNote/01/Graphics01/image-20220328234655386.png" alt="image-20220328234655386"></p>
<p><img src="/2022/05/05/GraphicsNote/01/Graphics01/image-20220329183804050.png" alt="image-20220329183804050"></p>
<h4 id="作业内容"><a href="#作业内容" class="headerlink" title="作业内容"></a>作业内容</h4><h5 id="任务目标"><a href="#任务目标" class="headerlink" title="任务目标"></a>任务目标</h5><p>本次作业的任务是填写一个旋转矩阵和一个透视投影矩阵。给定三维下三个点 v0(2.0, 0.0, −2.0), v1(0.0, 2.0, −2.0), v2(−2.0, 0.0, −2.0), 你需要将这三个点的坐标变换为屏幕坐标并在屏幕上绘制出对应的线框三角形 (在代码框架中，我们已经提供了 draw_triangle 函数，所以你只需要去构建变换矩阵即可)。</p>
<p>以下是你需要在 main.cpp 中修改的函数：</p>
<p><code>Eigen::Matrix4f get_model_matrix(float rotation_angle)</code></p>
<p>逐个元素地构建模型变换矩阵并返回该矩阵。在此函数中，你只需要实现三维中绕 z 轴旋转的变换矩阵，而不用处理平移与缩放。</p>
<p><code>Eigen::Matrix4f get_projection_matrix(float eye_fov, float aspect_ratio, float zNear, float zFar)</code></p>
<p>使用给定的参数逐个元素地构建透视投影矩阵并返回该矩阵。<br><code>[Optional] main()</code></p>
<p>自行补充你所需的其他操作。</p>
<p>提高部分：</p>
<p><code>Eigen::Matrix4f get_rotation(Vector3f axis, float angle)</code></p>
<p>在此之中给出按<strong>过原点的任意轴</strong>旋转的矩阵（罗德里格斯公式）</p>
<h5 id="代码解释"><a href="#代码解释" class="headerlink" title="代码解释"></a>代码解释</h5><p>模型变换，以Z轴旋转</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function">Eigen::Matrix4f <span class="hljs-title">get_model_matrix</span><span class="hljs-params">(<span class="hljs-type">float</span> rotation_angle)</span><span class="hljs-comment">//模型变换(以z轴旋转)</span></span><br><span class="hljs-function"></span>&#123;<br>    Eigen::Matrix4f model = Eigen::Matrix4f::<span class="hljs-built_in">Identity</span>();<span class="hljs-comment">//单位矩阵初始化// <span class="hljs-doctag">TODO:</span> Implement this function</span><br>    <span class="hljs-comment">// Create the model matrix for rotating the triangle around the Z axis.</span><br>    <span class="hljs-comment">// Then return it.</span><br><br>    <span class="hljs-type">float</span> radian = rotation_angle / <span class="hljs-number">180.0</span> * MY_PI;<span class="hljs-comment">//转换为弧度制</span><br><br>    Eigen::Matrix4f translate;<span class="hljs-comment">//以z轴旋转</span><br>    translate &lt;&lt; <br>        <span class="hljs-built_in">cos</span>(radian), -<span class="hljs-built_in">sin</span>(radian), <span class="hljs-number">0</span>, <span class="hljs-number">0</span>,<br>        <span class="hljs-built_in">sin</span>(radian), <span class="hljs-built_in">cos</span>(radian), <span class="hljs-number">0</span>, <span class="hljs-number">0</span>,<br>        <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>,<br>        <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>;<br><br>    model = translate * model;<br><br>    <span class="hljs-keyword">return</span> model;<br>&#125;`<br></code></pre></td></tr></table></figure>

<p>透视投影变换矩阵</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">Eigen::Matrix4f <span class="hljs-title">get_projection_matrix</span><span class="hljs-params">(<span class="hljs-type">float</span> eye_fov, <span class="hljs-type">float</span> aspect_ratio,<span class="hljs-type">float</span> zNear, <span class="hljs-type">float</span> zFar)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// Students will implement this functionEigen::Matrix4f projection = Eigen::Matrix4f::Identity();//单位矩阵初始化</span><br><br>    <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> Implement this function</span><br>    <span class="hljs-comment">// Create the projection matrix for the given parameters.</span><br>    <span class="hljs-comment">// Then return it.</span><br><br>    Eigen::Matrix4f persp2ortho;<span class="hljs-comment">//视锥体结构正则化矩阵</span><br>    persp2ortho &lt;&lt;<br>        zNear, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>,<br>        <span class="hljs-number">0</span>, zNear, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>,<br>        <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, zNear + zFar, -zNear * zFar,<br>        <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>;<br><br>    <span class="hljs-type">float</span> halfView = eye_fov * MY_PI / <span class="hljs-number">180.0</span> / <span class="hljs-number">2</span>;<span class="hljs-comment">//半视界弧度数</span><br>    <span class="hljs-type">float</span> top = zNear * <span class="hljs-built_in">tan</span>(halfView);<span class="hljs-comment">//正则化体顶面</span><br>    <span class="hljs-type">float</span> bottom = -top;<br>    <span class="hljs-type">float</span> right = top * aspect_ratio;<span class="hljs-comment">//宽高比得出左右</span><br>    <span class="hljs-type">float</span> left = -right;<br><br>    Eigen::Matrix4f orthoTrans;<span class="hljs-comment">//正交投影中坐标正则化</span><br>    orthoTrans &lt;&lt;<br>        <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, -(left + right) / <span class="hljs-number">2</span>,<br>        <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, -(top + bottom) / <span class="hljs-number">2</span>,<br>        <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, -(zNear + zFar) / <span class="hljs-number">2</span>,<br>        <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>;<br><br>    Eigen::Matrix4f orthoScale;<span class="hljs-comment">//正交投影中比例正则化</span><br>    orthoScale &lt;&lt;<br>        <span class="hljs-number">2</span> / (right - left), <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>,<br>        <span class="hljs-number">0</span>, <span class="hljs-number">2</span> / (top - bottom), <span class="hljs-number">0</span>, <span class="hljs-number">0</span>,<br>        <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">2</span> / (zNear - zFar), <span class="hljs-number">0</span>,<br>        <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>;<br><br>    Eigen::Matrix4f orthoMatrix = orthoScale * orthoTrans;<span class="hljs-comment">//正交投影</span><br><br>    projection = orthoMatrix * persp2ortho;<span class="hljs-comment">//透视投影</span><br><br>    <span class="hljs-keyword">return</span> projection;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>提高部分</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function">Eigen::Matrix4f <span class="hljs-title">get_rotation</span><span class="hljs-params">(Vector3f axis, <span class="hljs-type">float</span> angle)</span></span><br><span class="hljs-function"></span>&#123;<br>    Matrix4f model = Matrix4f::<span class="hljs-built_in">Identity</span>();<br>    Matrix4f I = Matrix4f::<span class="hljs-built_in">Identity</span>();<br>    <span class="hljs-type">float</span> radian = angle / <span class="hljs-number">180.0</span> * MY_PI;<span class="hljs-comment">//转换为弧度制</span><br>    Vector4f axis_4f;<br>    axis_4f &lt;&lt; axis[<span class="hljs-number">0</span>], axis[<span class="hljs-number">1</span>], axis[<span class="hljs-number">2</span>], <span class="hljs-number">0</span>;<br>    Matrix4f N;<br>    N &lt;&lt;<br>        <span class="hljs-number">0</span>, -axis.<span class="hljs-built_in">row</span>(<span class="hljs-number">3</span>), axis.<span class="hljs-built_in">row</span>(<span class="hljs-number">2</span>), <span class="hljs-number">0</span>,<br>        axis.<span class="hljs-built_in">row</span>(<span class="hljs-number">3</span>), <span class="hljs-number">0</span>, -axis.<span class="hljs-built_in">row</span>(<span class="hljs-number">0</span>), <span class="hljs-number">0</span>,<br>        -axis.<span class="hljs-built_in">row</span>(<span class="hljs-number">2</span>), axis.<span class="hljs-built_in">row</span>(<span class="hljs-number">0</span>), <span class="hljs-number">0</span>, <span class="hljs-number">0</span>,<br>        <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>;<br>    model = <span class="hljs-built_in">cos</span>(radian) * I + (<span class="hljs-number">1</span> - <span class="hljs-built_in">cos</span>(radian)) * axis_4f * axis_4f.<span class="hljs-built_in">transpose</span>() + <span class="hljs-built_in">sin</span>(radian) * N;<br>    <span class="hljs-built_in">model</span>(<span class="hljs-number">3</span>, <span class="hljs-number">3</span>) = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">return</span> model;<br>&#125;<br></code></pre></td></tr></table></figure>
<div id="paginator"></div></div><div id="post-footer"><div id="pages"><div id="footer-link" style="right: calc(50% - 1px);order: 1;border-right: 1px solid #fe2;padding-left: unset;max-width: calc(50% - 4px);"><a href="/2022/05/05/GraphicsNote/02/Graphics02/">← Next 光栅化成像-光栅化</a></div><div id="footer-link" style="left: 50%;order: 0;border-left: 1px solid #fe2;padding-right: unset;max-width: calc(50% - 5px);"><a href="/2022/05/05/GraphicsNote/00/Graphics00/">计算机图形学基础-课程简介 Prev →</a></div></div></div><details id="reward"><summary>打赏</summary><div id="alipay"><span>支付宝 | Alipay</span><br><img src="/img/Alipay.png"></div><div id="wechat"><span>微信 | WeChat</span><br><img src="/img/WeChat.png"></div></details></div><div id="bottom-btn"><a id="to-top" onClick="index.scrolltop();" title="to top" style="opacity: 0; display: none;">∧</a></div></article><div class="aside-box"><aside><div id="aside-top"><div id="about"><a href="/" id="logo"><img src="https://ak.hypergryph.com/assets/index/images/ak/pc/faction/1.png" alt="Logo"></a><h1 id="Dr"><a href="/">John Doe</a></h1><div id="description"><p></p></div><!--if page.published === undefined--><section id="total"><a id="total-archives" href="/archives"><span class="total-title">Archives Total:</span><span class="total-number">5</span></a><div id="total-tags"><span class="total-title">Tags:</span><span class="total-number">4</span></div><div id="total-categories"><span class="total-title">Categories:</span><span class="total-number">2</span></div></section></div><div id="aside-block"><div id="toc-div"><h1>INDEX</h1><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8"><span class="toc-number">1.</span> <span class="toc-text">现代计算机图形学基础入门</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%89%E6%A0%85%E5%8C%96%E6%88%90%E5%83%8F"><span class="toc-number">1.1.</span> <span class="toc-text">光栅化成像</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%86%E5%9B%BE%E5%8F%98%E6%8D%A2"><span class="toc-number">1.1.1.</span> <span class="toc-text">视图变换</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A8%A1%E5%9E%8B%E5%8F%98%E6%8D%A2-M"><span class="toc-number">1.1.1.1.</span> <span class="toc-text">模型变换 M</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%91%84%E5%83%8F%E6%9C%BA%E5%8F%98%E6%8D%A2-V"><span class="toc-number">1.1.1.2.</span> <span class="toc-text">摄像机变换 V</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8A%95%E5%BD%B1%E5%8F%98%E6%8D%A2-P"><span class="toc-number">1.1.1.3.</span> <span class="toc-text">投影变换 P</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%AD%A3%E4%BA%A4%E6%8A%95%E5%BD%B1-Perspective"><span class="toc-number">1.1.1.3.1.</span> <span class="toc-text">正交投影 Perspective</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%80%8F%E8%A7%86%E6%8A%95%E5%BD%B1-Orthographic"><span class="toc-number">1.1.1.3.2.</span> <span class="toc-text">透视投影 Orthographic</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%86%E5%8F%A3%E5%8F%98%E5%8C%96-Vp"><span class="toc-number">1.1.1.4.</span> <span class="toc-text">视口变化 Vp</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%9C%E4%B8%9A%E5%86%85%E5%AE%B9"><span class="toc-number">1.1.1.5.</span> <span class="toc-text">作业内容</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%BB%E5%8A%A1%E7%9B%AE%E6%A0%87"><span class="toc-number">1.1.1.5.1.</span> <span class="toc-text">任务目标</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E8%A7%A3%E9%87%8A"><span class="toc-number">1.1.1.5.2.</span> <span class="toc-text">代码解释</span></a></li></ol></li></ol></li></ol></li></ol></li></ol></div></div></div><footer><nobr><span class="text-title">©</span><span class="text-content">1970 to 2020</span></nobr><br><nobr><span class="text-title">ICP</span><span class="text-content">——备案号——</span></nobr><br><text>published with <a target="_blank" rel="noopener" href="http://hexo.io">Hexo</a></text><text> Theme <a target="_blank" rel="noopener" href="https://github.com/Yue-plus/hexo-theme-arknights">Arknight</a></text><wbr><text>by <a target="_blank" rel="noopener" href="https://github.com/Yue-plus">Yue_plus</a></text></footer></aside></div></main><canvas id="canvas-dust"></canvas><script src="/js/search.js"></script><script>const reset=_=>{}</script><script src="//unpkg.com/@highlightjs/cdn-assets@11.4.0/highlight.min.js"></script><script src="/js/arknights.js"></script><script>document.addEventListener("load",reset())</script></body></html>