[{"title":"test","url":"/2022/05/05/test/","content":"\n","categories":["test"],"tags":["test01"]},{"title":"Hello World","url":"/2022/05/05/hello-world/","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.\nQuick StartCreate a new post$ hexo new &quot;My New Post&quot;\n\nMore info: Writing\nRun server$ hexo server\n\nMore info: Server\nGenerate static files$ hexo generate\n\nMore info: Generating\nDeploy to remote sites$ hexo deploy\n\nMore info: Deployment\n"},{"title":"基数排序","url":"/2022/05/06/%E7%AE%97%E6%B3%95/%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F/","content":"由于写之前刚学了C++，作死写了类和对象版本的，对象也没分好\n但可以用\n参考来源：《排序算法系列7》基数排序(桶排序) - 会敲代码的王秀才 - 博客园 (cnblogs.com)\n#include &lt;iostream&gt;#include &lt;array&gt;#include &lt;ctime&gt;#include &lt;math.h&gt;#include &lt;vector&gt;using namespace std;class MyArray&#123;\tfriend void operator&lt;&lt;(ostream&amp; cout, MyArray&amp; arr);public:\tstatic void setLength()\t&#123;\t\tcout &lt;&lt; &quot;请输入要参与桶排序的数据个数:&quot; &lt;&lt; endl;\t\tcin &gt;&gt; length;\t\tcout &lt;&lt; &quot;请输入数字的最大位数:&quot; &lt;&lt; endl;\t\tcin &gt;&gt; index;\t&#125;\tstatic int getLength()\t&#123;\t\treturn length;\t&#125;\tint getBucketSortTimes()\t&#123;\t\tint i = 0;\t&#125;\tvoid GetRandomArray()\t&#123;\t\tsrand((unsigned int)time(NULL));\t\tarr = new int[length];\t\tfor (int i = 0; i &lt; length; i++)\t\t&#123;\t\t\tarr[i] = rand() % (int)pow(10, index);\t\t&#125;\t&#125;public:\tstatic int length;\tstatic int index;\tint* arr;&#125;;int MyArray::length = 10000;//此处低于后期输入的length会导致Bucket类中new容量出现问题,应用全局变量替换int MyArray::index = 0;void operator&lt;&lt;(ostream&amp; cout, MyArray&amp; Data)&#123;\tcout &lt;&lt; &quot;现在的数据为:&quot; &lt;&lt; endl;\tfor (int i = 0; i &lt; MyArray::length; i++)\t&#123;\t\tcout &lt;&lt; Data.arr[i] &lt;&lt; &quot;\\t&quot;;\t\tif ((i + 1) % 10 == 0)\t\t&#123;\t\t\tcout &lt;&lt; endl;\t\t&#125;\t&#125;&#125;class Bucket&#123;\tfriend class Buckets;\tBucket()\t&#123;\t\tOneBucket = new int[lengthBucket]();\t\tsum = 0;\t&#125;public:\tint sum;private:\tstatic int lengthBucket;\tint* OneBucket;&#125;;int Bucket::lengthBucket = MyArray::getLength();class Buckets&#123;public:\tBuckets()\t&#123;\t\tTenBuckets = new Bucket[10]();\t&#125;\tvoid BucketSort(MyArray&amp; Data)\t&#123;\t\tint temp = 0;\t\tfor (int j = 0; j &lt; MyArray::index; j++)\t\t&#123;\t\t\tfor (int i = 0; i &lt; MyArray::length; i++)\t\t\t&#123;\t\t\t\tint index = Data.arr[i] / (int)pow(10, temp) % 10;\t\t\t\tTenBuckets[index].OneBucket[TenBuckets[index].sum++] = Data.arr[i];\t\t\t&#125;\t\t\t//for (int i = 0; i &lt; 10; i++)\t\t\t//&#123;\t\t\t//\tcout &lt;&lt; &quot;第&quot; &lt;&lt; i &lt;&lt; &quot;个有&quot; &lt;&lt; TenBuckets[i].sum &lt;&lt; endl;\t\t\t//&#125;\t\t\tint BucketIndex = 0;\t\t\tfor (int i = 0; i &lt; MyArray::length;)\t\t\t&#123;\t\t\t\tif (TenBuckets[BucketIndex].sum != 0)\t\t\t\t&#123;\t\t\t\t\tint tempIndexSum = 0;\t\t\t\t\twhile (TenBuckets[BucketIndex].sum &gt; tempIndexSum)\t\t\t\t\t&#123;\t\t\t\t\t\tData.arr[i++] = TenBuckets[BucketIndex].OneBucket[tempIndexSum++];\t\t\t\t\t&#125;\t\t\t\t\t\t\t\t\t&#125;\t\t\t\tBucketIndex++;\t\t\t&#125;\t\t\tfor (int i = 0; i &lt; 10; i++)\t\t\t&#123;\t\t\t\tTenBuckets[i].sum = 0;\t\t\t&#125;\t\t\ttemp++;\t\t\tcout &lt;&lt; Data;\t\t&#125;\t&#125;private:\tBucket* TenBuckets;&#125;;int main()&#123;\tMyArray::setLength();\tMyArray Data;\tData.GetRandomArray();\tcout &lt;&lt; Data;\tBuckets DigtalBuckets;\tDigtalBuckets.BucketSort(Data);\tsystem(&quot;pause&quot;);\treturn 0;&#125;\n\n","categories":["算法"],"tags":["代码","排序","C++","作业"]},{"title":"模拟收入分析","url":"/2022/05/06/%E7%AE%97%E6%B3%95/%E6%A8%A1%E6%8B%9F%E6%94%B6%E5%85%A5%E5%88%86%E6%9E%90/","content":"\n问题如果所示\n关于数据方面引用几组关键数据看中国人的收入情况 (baidu.com)分析，2%的人占有80%的财富，不得不说二八定理这种明显不公的分配，原来也只是理想\n文件名需要使用之前提到过的随机数生成部分代码，或者自己生成，或者将代码中文件名修改掉\n出于未知原因当数量过大，如1亿，输出结果会异常，但时间貌似没错，40万稳定使用\n以下图片中提到的直接求解$O(n,logn)$和$O(n)$均为众数和中位数一起的复杂度，也可当为中位数复杂度，因为代码中众数均为$O(n)$\n\n\n多做几次实验会发现正态分布情况下所用时间比其他情况下所用时间更多\n#include &lt;iostream&gt;#include &lt;math.h&gt;#include &lt;fstream&gt;#include &lt;string&gt;#include &lt;random&gt;using namespace std;int InsertSort(int array[], int left, int right);int GetPivotIndex(int array[], int left, int right);int Partition(int array[], int left, int right, int pivot_index);int BFPRT(int array[], int left, int right, int k);int length = 400000;void getRandomNumber(const int&amp; length)&#123;\tofstream ofsNormal;\tofstream ofsUniform;\tofstream ofsTrue;\t\tstring name = to_string(length);\tmt19937 seed(random_device&#123;&#125;());\tuniform_int_distribution&lt;&gt;rangeUniform(17000, 37000);\tnormal_distribution&lt;&gt;rangeNormal(27000, 9000);\tofsNormal.open(&quot;Normal_DataOfLength_&quot; + name + &quot;.txt&quot;, ios::out);\tfor (int i = 0; i &lt; length; i++)\t&#123;\t\tint data = (int)(rangeNormal(seed));\t\tif (data &lt; 0)\t\t&#123;\t\t\ti--;\t\t\tcontinue;\t\t&#125;\t\telse\t\t&#123;\t\t\tofsNormal &lt;&lt; data &lt;&lt; endl;\t\t&#125;\t\t\t&#125;\tcout &lt;&lt; &quot;Done with Normal&quot; &lt;&lt; endl;\tofsNormal.close();\tofsUniform.open(&quot;Uniform_DataOfLength_&quot; + name + &quot;.txt&quot;, ios::out);\tfor (int i = 0; i &lt; length; i++)\t&#123;\t\tint data = (int)(rangeUniform(seed));\t\tif (data &lt; 0)\t\t&#123;\t\t\ti--;\t\t\tcontinue;\t\t&#125;\t\telse\t\t&#123;\t\t\tofsUniform &lt;&lt; data &lt;&lt; endl;\t\t&#125;\t&#125;\tcout &lt;&lt; &quot;Done with Uniform&quot; &lt;&lt; endl;\tofsUniform.close();\tuniform_int_distribution&lt;&gt;rangeTrueUniform(100000, 1500000);//平均分布\tnormal_distribution&lt;&gt;rangeTrueNormal(11500, 3000);//正态分布\tint range01 = (int)(length * 0.98);\tint range02 = length - range01;\tofsTrue.open(&quot;True_DataOfLength_&quot; + name + &quot;.txt&quot;, ios::out);\tfor (int i = 0; i &lt; range01; i++)\t&#123;\t\tint data = (int)(rangeTrueNormal(seed));\t\tif (data &lt; 0)\t\t&#123;\t\t\ti--;\t\t\tcontinue;\t\t&#125;\t\telse\t\t&#123;\t\t\tofsTrue &lt;&lt; data &lt;&lt; endl;\t\t&#125;\t&#125;\tfor (int i = 0; i &lt; range02; i++)\t&#123;\t\tint data = (int)(rangeTrueUniform(seed));\t\tif (data &lt; 0)\t\t&#123;\t\t\ti--;\t\t\tcontinue;\t\t&#125;\t\telse\t\t&#123;\t\t\tofsTrue &lt;&lt; data &lt;&lt; endl;\t\t&#125;\t&#125;\tcout &lt;&lt; &quot;Done with True&quot; &lt;&lt; endl;\tofsTrue.close();&#125;int InsertSort(int array[], int left, int right)&#123;\tint temp;\tint j;\tfor (int i = left + 1; i &lt;= right; i++)\t&#123;\t\ttemp = array[i];\t\tj = i - 1;\t\twhile (j &gt;= left &amp;&amp; array[j] &gt; temp)\t\t\tarray[j + 1] = array[j--];\t\tarray[j + 1] = temp;\t&#125;\treturn ((right - left) &gt;&gt; 1) + left;&#125;int GetPivotIndex(int array[], int left, int right)&#123;\tif (right - left &lt; 5)\t\treturn InsertSort(array, left, right);\tint sub_right = left - 1;\t// 每五个作为一组，求出中位数，并把这些中位数全部依次移动到数组左边\tfor (int i = left; i + 4 &lt;= right; i += 5)\t&#123;\t\tint index = InsertSort(array, i, i + 4);\t\tswap(array[++sub_right], array[index]);\t&#125;\t// 利用 BFPRT 得到这些中位数的中位数下标（即主元下标）\treturn BFPRT(array, left, sub_right, ((sub_right - left + 1) &gt;&gt; 1) + 1);&#125;int Partition(int array[], int left, int right, int pivot_index)&#123;\tswap(array[pivot_index], array[right]); // 把主元放置于末尾\tint partition_index = left; // 跟踪划分的分界线\tfor (int i = left; i &lt; right; i++)\t&#123;\t\tif (array[i] &lt; array[right])\t\t&#123;\t\t\tswap(array[partition_index++], array[i]); // 比主元小的都放在左侧\t\t&#125;\t&#125;\tswap(array[partition_index], array[right]); // 最后把主元换回来\treturn partition_index;&#125;int BFPRT(int array[], int left, int right, int k)&#123;\tint pivot_index = GetPivotIndex(array, left, right); // 得到中位数的中位数下标（即主元下标）\tint partition_index = Partition(array, left, right, pivot_index); // 进行划分，返回划分边界\tint num = partition_index - left + 1;\tif (num == k)\t\treturn partition_index;\telse if (num &gt; k)\t\treturn BFPRT(array, left, partition_index - 1, k);\telse\t\treturn BFPRT(array, partition_index + 1, right, k - num);&#125;void swap(int&amp; a, int&amp; b)&#123;\tint temp = a;\ta = b;\tb = temp;&#125;int randomizedPartition(int array[], int left, int right)&#123;\tmt19937 seed(random_device&#123;&#125;());\tuniform_int_distribution&lt;&gt;range(left, right);\tint s = range(seed);\tswap(array[s], array[right]);\tint x = array[right];\tint i = left - 1;\tfor (int j = left; j &lt; right - 1; j++)\t&#123;\t\tif (array[j] &lt;= x)\t\t&#123;\t\t\tswap(array[i + 1], array[j]);\t\t\ti++;\t\t&#125;\t&#125;\t\tswap(array[i + 1], array[right]);\treturn i + 1;\t&#125;int randomizedSelection(int array[], int left, int right, int k)&#123;\tint q = randomizedPartition(array, left, right);\tint x = 0;\tif (k == (q - left + 1))\t&#123;\t\tx = array[q];\t&#125;\tif (k &lt; (q - left + 1))\t&#123;\t\tx = randomizedSelection(array, left, q - 1, k);\t&#125;\tif (k &gt; (q - left + 1))\t&#123;\t\tx = randomizedSelection(array, q + 1, right, k - (q - left + 1));\t&#125;\treturn x;&#125;void randomizedQuickSort(int array[], int left, int right)&#123;\tif (left &lt; right)\t&#123;\t\tint q = randomizedPartition(array, left, right);\t\trandomizedQuickSort(array, left, q - 1);\t\trandomizedQuickSort(array, q + 1, right);\t&#125;&#125;void QuickSort(int list[], int left, int right)&#123;\tint low = left;\tint high = right;\tint mid = list[(low + high) / 2];\twhile (low &lt;= high)\t&#123;\t\twhile (list[low] &lt; mid &amp;&amp; low &lt; right)\t\t&#123;\t\t\tlow++;\t\t&#125;\t\twhile (list[high] &gt; mid &amp;&amp; high &gt; left)\t\t&#123;\t\t\thigh--;\t\t&#125;\t\tif (low &lt;= high)\t\t&#123;\t\t\tswap(list[low], list[high]);\t\t\tlow++;\t\t\thigh--;\t\t&#125;\t&#125;\tif (left &lt; high)\t&#123;\t\tQuickSort(list, left, high);\t&#125;\tif (low &lt; right)\t&#123;\t\tQuickSort(list, low, right);\t&#125;&#125;int getArrayAnalysis(string DataType)&#123;\tint i = 0;\tunsigned long long int sum = 0;\tint* dataPool = new int[10000000]();\tint* data = new int[length];\tifstream scanFile(DataType + &quot;_DataOfLength_400000.txt&quot;, ios::in);\tif (!scanFile)\t&#123;\t\treturn -1;\t&#125;\twhile (scanFile &gt;&gt; data[i])\t&#123;\t\tdataPool[data[i]]++;\t\tsum += data[i++];\t&#125;\tint max = 0;\tfor (int index = 0; index &lt; 10000000; index++)\t&#123;\t\tif (dataPool[index] &gt; dataPool[max])\t\t&#123;\t\t\tmax = index;\t\t&#125;\t&#125;\trandomizedSelection(data, 0, length - 1, length / 2);\t//data[BFPRT(data, 0, length - 1, length / 2)];\t//cout &lt;&lt; &quot;平均数为：&quot; &lt;&lt; sum / length &lt;&lt; endl;\t//cout &lt;&lt; &quot;众数为：&quot; &lt;&lt; max &lt;&lt; endl;\t//clock_t start01, finish01;\t//start01 = clock();\t//cout &lt;&lt; &quot;中位数为：&quot; &lt;&lt; randomizedSelection(data, 0, length - 1, length / 2) &lt;&lt; endl;\t//finish01 = clock();\t//cout &lt;&lt; &quot;Time:&quot; &lt;&lt; (double)(finish01 - start01) / CLOCKS_PER_SEC &lt;&lt; &quot;s&quot; &lt;&lt; endl;\t//system(&quot;pause&quot;);\t//cout &lt;&lt; &quot;中位数为：&quot; &lt;&lt; data[BFPRT(data, 0, length - 1, length / 2)] &lt;&lt; endl;\t//scanFile.close();\tdelete[] dataPool;\tdelete[] data;\treturn 0;&#125;int getArrayAnalysis(string DataType,int)&#123;\tint i = 0;\tunsigned long long int sum = 0;\tint* data = new int[length];\tifstream scanFile(DataType + &quot;_DataOfLength_400000.txt&quot;, ios::in);\tif (!scanFile)\t&#123;\t\treturn -1;\t&#125;\twhile (scanFile &gt;&gt; data[i])\t&#123;\t\tsum += data[i++];\t&#125;\tQuickSort(data, 0, length - 1);\tunsigned long maxCount = 0;\tint most = 0;\tfor (int i = 0; i &lt; length - 1; i++)\t&#123;\t\tunsigned long count = 0;\t\twhile (data[i] == data[i + 1])\t\t&#123;\t\t\tcount++;\t\t\ti++;\t\t&#125;\t\tif (count &gt; maxCount)\t\t&#123;\t\t\tmaxCount = count;\t\t\tmost = i;\t\t&#125;\t&#125;\t//cout &lt;&lt; &quot;平均数为：&quot; &lt;&lt; sum / length &lt;&lt; endl;\t//cout &lt;&lt; &quot;众数为：&quot; &lt;&lt; data[most] &lt;&lt; endl;\t//clock_t start01, finish01;\t//start01 = clock();\t//cout &lt;&lt; &quot;中位数为：&quot; &lt;&lt; data[length / 2] &lt;&lt; endl;\t//finish01 = clock();\t//cout &lt;&lt; &quot;Time:&quot; &lt;&lt; (double)(finish01 - start01) / CLOCKS_PER_SEC &lt;&lt; &quot;s&quot; &lt;&lt; endl;\t//system(&quot;pause&quot;);\t\tscanFile.close();\tdelete[] data;\treturn 0;&#125;int main()&#123;\t//getRandomNumber(length);\tclock_t start01, finish01;\tclock_t start02, finish02;\tclock_t start03, finish03;\tclock_t start04, finish04;\tclock_t start05, finish05;\tclock_t start06, finish06;\t\tcout &lt;&lt; &quot;正态分布：&quot; &lt;&lt; endl;\tgetArrayAnalysis(&quot;Normal&quot;);\tstart01 = clock();\tfor (int i = 0; i &lt; 10; i++)\t&#123;\t\tgetArrayAnalysis(&quot;Normal&quot;);\t&#125;\tfinish01 = clock();\tcout &lt;&lt; &quot;直接求解Time:&quot; &lt;&lt; (double)((double)finish01 - start01) / CLOCKS_PER_SEC / 10 &lt;&lt; &quot;s&quot; &lt;&lt; endl;\tstart02 = clock();\tfor (int i = 0; i &lt; 10; i++)\t&#123;\t\tgetArrayAnalysis(&quot;Normal&quot;, 1);\t&#125;\tfinish02 = clock();\tcout &lt;&lt; &quot;排序求解Time:&quot; &lt;&lt; (double)((double)finish02 - start02) / CLOCKS_PER_SEC / 10 &lt;&lt; &quot;s&quot; &lt;&lt; endl;\tcout &lt;&lt; &quot;平均分布：&quot; &lt;&lt; endl;\tstart03 = clock();\tfor (int i = 0; i &lt; 10; i++)\t&#123;\t\tgetArrayAnalysis(&quot;Uniform&quot;);\t&#125;\tfinish03 = clock();\tcout &lt;&lt; &quot;直接求解Time:&quot; &lt;&lt; (double)((double)finish03 - start03) / CLOCKS_PER_SEC / 10 &lt;&lt; &quot;s&quot; &lt;&lt; endl;\tstart04 = clock();\tfor (int i = 0; i &lt; 10; i++)\t&#123;\t\tgetArrayAnalysis(&quot;Uniform&quot;, 1);\t&#125;\tfinish04 = clock();\tcout &lt;&lt; &quot;排序求解Time:&quot; &lt;&lt; (double)((double)finish04 - start04) / CLOCKS_PER_SEC / 10 &lt;&lt; &quot;s&quot; &lt;&lt; endl;\tcout &lt;&lt; &quot;真实情况：&quot; &lt;&lt; endl;\tstart05 = clock();\tfor (int i = 0; i &lt; 10; i++)\t&#123;\t\tgetArrayAnalysis(&quot;True&quot;);\t&#125;\tfinish05 = clock();\tcout &lt;&lt; &quot;直接求解Time:&quot; &lt;&lt; (double)((double)finish05 - start05) / CLOCKS_PER_SEC / 10 &lt;&lt; &quot;s&quot; &lt;&lt; endl;\tstart06 = clock();\tfor (int i = 0; i &lt; 10; i++)\t&#123;\t\tgetArrayAnalysis(&quot;True&quot;, 1);\t&#125;\tfinish06 = clock();\tcout &lt;&lt; &quot;排序求解Time:&quot; &lt;&lt; (double)((double)finish06 - start06) / CLOCKS_PER_SEC / 10 &lt;&lt; &quot;s&quot; &lt;&lt; endl;\t\tsystem(&quot;pause&quot;);\treturn 0;&#125;\n\n\n\n","categories":["算法"],"tags":["代码","排序","C++","作业","随机数"]},{"title":"随机数生成","url":"/2022/05/06/%E7%AE%97%E6%B3%95/%E9%9A%8F%E6%9C%BA%E6%95%B0%E7%94%9F%E6%88%90/","content":"使用C++自带库生成随机数\n伪随机数生成 - cppreference.com\n以下代码会在0到50万之间生成length个整数，并写入到文件中\n#include &lt;iostream&gt;#include &lt;math.h&gt;#include &lt;fstream&gt;#include &lt;string&gt;#include &lt;random&gt;#include &lt;time.h&gt;using namespace std;void getRandomNumber(const int &amp;length)&#123;\tofstream ofs;\tstring name = to_string(length);\tmt19937 seed(random_device&#123;&#125;());\tuniform_int_distribution&lt;&gt;range(0, 500000);//平均分布范围\tofs.open(&quot;DataOfLength_&quot; + name + &quot;.txt&quot;, ios::out);\tfor (int i = 0; i &lt; length; i++)\t&#123;\t\t\tofs &lt;&lt; range(seed) &lt;&lt; endl;\t&#125;\tcout &lt;&lt; &quot;Done&quot; &lt;&lt; endl;\tofs.close();&#125;int main()&#123;\tclock_t start, finish;\t\tint length;\tcout &lt;&lt; &quot;输入数据数量：&quot; &lt;&lt; endl;\tcin &gt;&gt; length;\tgetRandomNumber(length);\tsystem(&quot;Done&quot;);\treturn 0;&#125;\n\n","categories":["算法"],"tags":["代码","C++","作业","随机数"]},{"title":"计算机图形学基础-课程简介","url":"/2022/05/05/GraphicsNote/00/Graphics00/","content":"现代计算机图形学基础入门前言本课程将全面而系统地介绍现代计算机图形学的四大组成部分：\n\n光栅化成像\n几何表示\n光的传播理论\n动画与模拟\n\n每个方面都会从基础原理出发讲解到实际应用，并介绍前沿的理论研究。通过本课程，你可以学习到计算机图形学背后的数学和物理知识，并锻炼实际的编程能力。\n顾名思义，作为入门，本课程会尽可能的覆盖图形学的方方面面，把每一部分的基本概念都尽可能说清楚，让大家对计算机图形学有一个完整的、自上而下的全局把握。全局的理解很重要，学完本课程后，你会了解到图形学不等于 OpenGL，不等于光线追踪，而是一套生成整个虚拟世界的方法。从本课程的标题，大家还可以看到“现代”二字，也就是说，这门课所要给大家介绍的都是现代化的知识，也都是现代图形学工业界需要的图形学基础。\n本课程与其它图形学教程还有一个重要的区别，那就是本课程不会讲授 OpenGL，甚至不会提及这个概念。本课程所讲授的内容是图形学背后的原理，而不是如何使用一个特定的图形学 API。在学习完这门课的时候，你一定有能力自己使用 OpenGL 写实时渲染的程序。另外，本课程并不涉及计算机视觉、图像视频处理、深度学习，也不会介绍游戏引擎与三维建模软件的使用。\n链接相关课程相关\n课程链接：GAMES101-现代计算机图形学入门-闫令琪_哔哩哔哩_bilibili\n课程主页：https://sites.cs.ucsb.edu/~lingqi/teaching/games101.html\n作业链接：http://games-cn.org/forums/topic/allhw/\n截止到2022年3月25日17:17:59该网页格式已崩坏，作业内容请在页面下部查看\n\n\n\n引用资料\n课程笔记：\n(22条消息) 计算机图形学笔记_剑 来!的博客-CSDN博客\n计算机图形学系列笔记 - 知乎 (zhihu.com)\n\n\n作业答案（参考）：\n计算机图形学学习笔记 - 知乎 (zhihu.com)\n计算机图形学 - 随笔分类 - levelly - 博客园 (cnblogs.com)\n(22条消息) GAMES101:作业6_南酒猫的博客-CSDN博客_games101作业6\n\n\n环境搭建：\n[工具]包管理工具Vcpkg 的使用 - 知乎 (zhihu.com)\n(22条消息) vcpkg + CMake_力为的博客-CSDN博客_cmake vcpkg\n\n\n\n环境配置本课程作业需要使用C++编程完成，依赖库有：\n\nEigen\nOpenCV\n\n虽然课程有提供配置完全环境的虚拟机，但对于使用非虚拟机环境，建议使用VCPKG进行环境搭建，具体内容参考环境搭建内容\n使用VCPKG常用操作：\n\n命令提示符到目录\n\n盘符：\ncd 文件夹目录\n\n\n\nVCPKG常用命令\n\n查看支持的库 VCPKG search\n\n安装一个库 VCPKG install 库名:版本\n注：可以用 eigen:x86-windows或eigen:x64-windows指定安装的版本，可以使用的版本还包括 x64-windows-static x64-windows x86-windows-static x86-windows.若不指定默认为32位；添加环境变量 `VCPKG_DEFAULT_TRIPLET=x64-windows` 可使默认集成位64位\n\n查看已安装的库 VCPKG list\n\n移除已安装的库 VCPKG remove 库名\n\n集成到全局 VCPKG integrate install\n\n\n\n\n如果使用的是Visual Studio出现卡顿，请调整项目至Release x64以获得更好的性能\n","categories":["计算机图形学"],"tags":["笔记","GAMES101"]},{"title":"光栅化成像-光栅化","url":"/2022/05/05/GraphicsNote/02/Graphics02/","content":"现代计算机图形学基础入门光栅化成像光栅化本节内容附加资料：\n\n计算机图形学三：直线光栅化的数值微分算法,中点Brensenham算法和三角形的光栅化 - 知乎 (zhihu.com)\n\n在进入具体的直线光栅化以及三角形光栅化算法之前，我们首先需要知道光栅化是一个什么样的过程。\n简单来说光栅化的目的就是将想要展现的物体给真正现实到屏幕上的过程，因为我们的物体其实都是一个个顶点数据来表示的，如何将这些蕴含几何信息的数据转化为屏幕上的像素点就是光栅化所考虑的东西。\n比如说一条直线，究竟该用哪些像素点去逼近它，一个三角形，又用哪些像素集合表示它，这都是光栅化的过程。\n在上一节中物体已经被映射到了屏幕上，那么屏幕是如何显示出来的呢\n三角形的光栅化为什么不是四边形五边形的光栅化，偏偏要谈三角形呢，因为三角形是最基本的多边形，大部分的模型都是用一个个三角形面表示，且任意的其它多边形其实都可以转化成多个三角形的形式，因此三角形的光栅化可以说是图形学中最基础的部分了。\n\n那么三角形会在屏幕上被显示成什么呢\n\n离散化三角形做到这一步我们需要采样\n请注意，采样的概念在接下来的文章中将会出现多次\n概念化解释：取样也叫采样，是把连续的模拟量用一个个离散的点来表示。将时间轴上连续的信号每隔一定的时间间隔抽取出一个信号的幅度样本，使其成为时间上离散的脉冲序列。\n\n如果我们将各个像素的中心点是否在三角形中作为唯一的判定标准，那么三角形将会被这样显示\n\n\n对应的伪代码如下\n\n经过这样的简单采样，三角形将会被这样显示出来\n\n内与外上面提到的采样是针对整个屏幕空间进行的，其中有一个函数inside(…)负责返回像素判定点是否在三角形内，我们该如何实现它呢\n\n例如在这幅图中，该如何判断任意一点是否在三角形之内呢\n利用叉乘的性质，如果满足\n\n\n\n\n\n以上三个多项式结果同号，则点在三角形内，否则不在\n边界情况如果空间中有多个三角形，而一个像素采样点恰巧在这两个三角形的边界处，那该如何判定呢\n\n对于这种情况需要自己进行判断，并没有统一标准，我们需要知道图形学的宗旨：看起来真实就可以\n优化方法因此自然的，只需要遍历每一个点就可以得出三角形的光栅化结果了，当然我们还可以进一步的进行优化，因为显然并没有必要去测试屏幕中的每一个点，一个三角形面可能只占屏幕很小的部分，可以利用一个包围盒（bounding box）包围住想要测试的三角形，只对该包围盒内的点进行采样测试\n\n除了包围盒外还有多种优化方法，例如在下面这幅图中，找到第一个判定成功的像素点后，直接进行后续同行的判定\n\n不同的方法适用于不同的情况，请灵活使用\n走样与反走样如果我们就此结束，将上一节中采样得到的离散化三角形显示出来的话，会是这种情况\n\n发生这种不真实的，我们不想要的现象被称为走样，走样产生的原因是采样不足，即采样量变化的过快，而采样速率跟不上，这里出现了多个名词，我们将会一一解释\n走样 Aliasing一张图片被放大会出现锯齿、拍摄电脑屏幕会出现奇怪的波纹、快速转动的车轮会看起来像是在倒转。这些现象都可以被称为“走样”，产生的原因即是“采样”不足。\n以上提到的三种情况分别对应以下名词：锯齿、摩尔纹以及车轮效应。\n\n\n其中锯齿与摩尔纹是屏幕在空间上的采样不足，而发生在现实中的倒转车轮效果则是大脑对光线的时间的采样不足。\n采样 Sample采样又名抽样，就像检测工厂中产品合格率使用的抽样调查一样\n采样在信号处理上有更多的含义，在这里不过多叙述，仅仅介绍一些基础概念\n上文已经提过，出现走样的原因是采样量变化的过快，而采样速率跟不上，如图所示\n\n使用同样的采样速率，不同频率的函数采样后的效果不同，可以观察到频率高的失真度越大\n在更极端一点的情况下，两种截然不同的信号在一种采样方式下，可能会得到完全相同的结果\n\n滤波 Filtering首先我们来看一下，一张图片经过傅里叶变换后从时域转变为频域的效果\n\n右侧这张图像的含义是\n\n中心点为低频信号，四周为高频信号\n十字效果产生的原因是图像非四方连续，导致信号的突变\n\n如果你还记得之前提到的内容的话，你就能知道这里的低频与高频的含义\n\n低频信号指颜色变换程度较小的地方\n高频信号值颜色变换程度较大的地方\n\n那么如果可以对图像的信号进行处理以后，再使用逆傅里叶变换逆向回图像会产生什么效果呢\n滤波：将信号中特定波段频率滤除的操作\n\n\n当然还可以对特定频段的信号进行过滤，产生出介于两者之间的效果\n\n卷积 Convolution这里的卷积是图形学上简化版本的卷积\n例如在如下的操作中\n\n在Result中计算的结果，是Signal中的值经过Filter（卷积核/滤波器）对周围值按权取值平均计算出的结果\n\n并依次往下进行，直至计算完Signal中的所有值\n卷积有如下定理\n在时域中的卷积，等于在频域中的乘积\n在时域中的乘积，等于在频域中的卷积\n由此在应用卷积时有以下两种路线\n一：\n\n在时域中使用卷积滤波\n\n二：\n\n使用傅里叶变换从时域转换为频域\n点乘由傅里叶变换来的卷积核\n使用逆傅里叶变换从频域转换为时域\n\n下图解释了这一定理，两种路线可以得到相同的效果\n\n滤波器 Filter滤波器有许多种，在此仅仅介绍一种盒状滤波器（Box Filter）\n\n将这个滤波器表示为图像如下\n\n\n\n盒子的大小也有影响，更大的滤波器会使得图像丧失更多高频信号，即更加模糊\n\n这一点可以这么思考\n\n如果盒子超过了图像尺寸，那么将会只显示出一个颜色\n如果盒子等于一个像素的大小，那么相当于没有做任何处理\n\n时域 Spatial Domain与频域 Frequency Domain上的采样\n图中左侧为时域，右侧为频域，对应关系为\n\n左侧经过傅里叶变换可得到右侧\n左侧区域的采样（a）乘上（c）冲激函数得到结果（e）,与此对应的频域操作则为卷积，即右侧的操作过程\n表现结果为（f）不断在冲激函数上重复的频谱\n\n我们不需要过多理解这些内容，这里我们只要知道在频域上的采样效果：在冲激函数上不断重复的频谱\n\n如图所示，上图是一种在频域的临界采样情况，若采样时采样间隔变大，则导致采样频率降低，不同的频谱会堆叠在一起，即图中的Aliasing，这里便发生了走样\n反走样Antialiasing走样发生的原因可总结为采样的速率慢于被采样对象的变化频率，在图形成像上的反走样由此可选择路线为\n\n增大采样速率\n增加屏幕分辨率\n\n\n降低被采样对象变化频率\n采样前过滤掉高频信号\n\n\n\n前者不必多说，即像素点的增加会减小空间上的采样间隔，对于后者而言如图所示\n\n\n非常值得注意的一点是：在采样前进行低通滤波处理，否则不会得到理想的效果\n\n[^两种情况]: 左侧为Blurred Aliasing，右侧为Antialiasing\n原因很好理解，因为对已经发生alias的频谱再使用低通滤波处理，得到的频谱仍有可能是存在alias的，所以模糊掉的只是已经存在的锯齿\n对于Pre-Filter的选择多种多样，在此以一个像素大小的Box Filter为例\n\n如图所示，在这一个像素大小的区域中，将根据图形覆盖的面积决定颜色的分布量，不再是最开始的采样结果中的01分布，而是具有过渡的状态\n以MSAA为例，将每个像素点的采样点从中心变为N×N的形势，对覆盖点的数量进行颜色插值\n\n\n虽然图示的采样点仅仅是被简单的划分出来，但在实际应用中会有多种划分方式\n反走样，或者在这里更多指的是抗锯齿，的方法有许多种，更多的思路不在此一一解释\n深度缓冲 Z-Buffer目前为止我们所接触的都是单个图形的光栅化过程，当场景中存在多个物体该如何判断它们的前后关系呢\n非常朴素的做法是根据物体的前后关系进行绘制顺序排列，即靠后的物体先绘制，靠前的物体后绘制，这种方法被称为画家算法\n\n其中的问题不言而喻，对于上图这种部分遮挡又部分被遮挡的情况，该算法无法完成绘制\n但我们可以把画家算法的思路从物体转移到像素，或者说是采样点上去，这就是Z-Buffer\n\nZ-Buffer算法需要为每个像素点维持一个深度数组记为zbuffer，其每个位置初始值置为无穷大（即离摄像机无穷远）。\n随后我们遍历每个三角形面上的每一个像素点[x,y]，如果该像素点的深度值z，小于zbuffer[x,y]中的值，则更新zbuffer[x,y]值为该点深度值z，并同时更新该像素点[x,y]的颜色为该三角形面上的该点的颜色。\n\n在接下来的内容中，为了便于理解z将被一直取正值，即值越大意味着离我们的距离越远，虽然在之前z一直是一个负数\n至此我们可以得到正确的遮挡关系了，在渲染时，会额外多一张反应z值的深度图\n\nframe buffer存储颜色信息\ndepth buffer（z-buffer）存储深度信息\n\n\n关于Z-Buffer算法的更多解释如下\n\n\n这个算法的时间复杂度是，因为它仅仅是找出了深度值最小的三角面，并没有进行排序，我们无须担心这一点的计算量很大，你可以相信你的GPU受过特殊训练\n作业内容任务目标在上次作业中，虽然我们在屏幕上画出一个线框三角形，但这看起来并不是那么的有趣。所以这一次我们继续推进一步——在屏幕上画出一个实心三角形，换言之，栅格化一个三角形。\n上一次作业中，在视口变化之后，我们调用了函数rasterize_wireframe(const Triangle&amp; t)。但这一次，你需要自己填写并调用函数 rasterize_triangle(const Triangle&amp; t)。\n该函数的内部工作流程如下：\n\n创建三角形的 2 维 bounding box。\n\n遍历此 bounding box 内的所有像素（使用其整数索引）。然后，使用像素中心的屏幕空间坐标来检查中心点是否在三角形内。\n\n如果在内部，则将其位置处的插值深度值 (interpolated depth value) 与深度缓冲区 (depth buffer) 中的相应值进行比较。\n\n如果当前点更靠近相机，请设置像素颜色并更新深度缓冲区 (depth buffer)。你需要修改的函数如下：\n\nrasterize_triangle(...): 执行三角形栅格化算法\nstatic bool insideTriangle(...): 测试点是否在三角形内\n\n\n你可以修改此函数的定义，这意味着，你可以按照自己的方式更新返回类型或函数参数。因为我们只知道三角形三个顶点处的深度值，所以对于三角形内部的像素，我们需要用插值的方法得到其深度值。我们已经为你处理好了这一部分，因为有关这方面的内容尚未在课程中涉及。插值的深度值被储存在变量 z_interpolated中。请注意我们是如何初始化 depth buffer 和注意 z values 的符号。为了方便同学们写代码，我们将 z 进行了反转，保证都是正数，并且越大表示离视点越远。在此次作业中，你无需处理旋转变换，只需为模型变换返回一个单位矩阵。最后，我们提供了两个 hard-coded 三角形来测试你的实现，如果程序实现正确，你将看到如下所示的输出图像:\n\n需要注意的是该作业框架中没有补充透视投影变换矩阵函数内容和模型变换矩阵函数内容，这里仅仅需要补充前者\n提高内容：\n用 super-sampling 处理 Anti-aliasing :\n你可能会注意到，当我们放大图像时，图像边缘会有锯齿感。我们可以用 super-sampling来解决这个问题，即对每个像素进行 2 * 2 采样，并比较前后的结果 (这里并不需要考虑像素与像素间的样本复用)。需要注意的点有，对于像素内的每一个样本都需要维护它自己的深度值，即每一个像素都需要维护一个 sample list。最后，如果你实现正确的话，你得到的三角形不应该有不正常的黑边。\n\n\n代码解释使用以下代码并不会得到与作业图完全相同的结果，因为这次的框架内容并没有让z保持正值\n若想得到相同的结果，请在将摄像机以Z轴旋转180°\n判断在三角形内部的采样点\nstatic bool insideTriangle(int x, int y, const Vector3f* _v){    // TODO : Implement this function to check if the point (x, y) is inside the triangle represented by _v[0], _v[1], _v[2]    //测试点的坐标为(x, y)    //三角形三点的坐标分别为_v[0], _v[1], _v[2]    //叉乘公式为(x1, y1)X(x2, y2) = x1*y2 - y1*x2    //（1）准备三角形各边的的向量    Eigen::Vector2f side1;    side1 &lt;&lt; _v[1].x() - _v[0].x(), _v[1].y() - _v[0].y();    Eigen::Vector2f side2;    side2 &lt;&lt; _v[2].x() - _v[1].x(), _v[2].y() - _v[1].y();    Eigen::Vector2f side3;    side3 &lt;&lt; _v[0].x() - _v[2].x(), _v[0].y() - _v[2].y();    //（2）准备测量点和三角形各点连线的向量    Eigen::Vector2f v1;    v1 &lt;&lt; x - _v[0].x(), y - _v[0].y();    Eigen::Vector2f v2;    v2 &lt;&lt; x - _v[1].x(), y - _v[1].y();    Eigen::Vector2f v3;    v3 &lt;&lt; x - _v[2].x(), y - _v[2].y();    //（3）三角形各边的的向量叉乘测量点和三角形各点连线的向量    float z1 = side1.x() * v1.y() - side1.y() * v1.x();    float z2 = side2.x() * v2.y() - side2.y() * v2.x();    float z3 = side3.x() * v3.y() - side3.y() * v3.x();    //（4）判断叉乘结果是否有相同的符号    if ((z1 &gt; 0 &amp;&amp; z2 &gt; 0 &amp;&amp; z3 &gt; 0) || (z1 &lt; 0 &amp;&amp; z2 &lt; 0 &amp;&amp; z3 &lt; 0))    {        return true;    }    else    {        return false;    }}\n\n或者是另一种简化版本\nstatic bool insideTriangle(int x, int y, const Vector3f* _v, int){    Vector2f point(x, y);    //A-0 B-1 C-2    //_v中存储的是三角形的三个顶点的三维坐标，使用.head取其x与y进行判断即可    Vector2f AB = _v[1].head(2) - _v[0].head(2);    Vector2f BC = _v[2].head(2) - _v[1].head(2);    Vector2f CA = _v[0].head(2) - _v[2].head(2);    Vector2f AP = point - _v[0].head(2);    Vector2f BP = point - _v[1].head(2);    Vector2f CP = point - _v[2].head(2);    return AB[0] * AP[1] - AB[1] * AP[0] &gt; 0        &amp;&amp; BC[0] * BP[1] - BC[1] * BP[0] &gt; 0        &amp;&amp; CA[0] * CP[1] - CA[1] * CP[0] &gt; 0        ||        AB[0] * AP[1] - AB[1] * AP[0] &lt; 0        &amp;&amp; BC[0] * BP[1] - BC[1] * BP[0] &lt; 0        &amp;&amp; CA[0] * CP[1] - CA[1] * CP[0] &lt; 0;}\n\n三角形的光栅化\n框架注释中给出的深度插值的部分，需要使用c++17标准\nvoid rst::rasterizer::rasterize_triangle(const Triangle&amp; t) {    //执行三角形栅格化算法    auto v = t.toVector4();    //f12进入toVector4()处后可以发现返回值是array&lt;Vector4f, 3&gt;    //我的理解：v是一个包含三个顶点信息的数组，每个顶点坐标用Vector4f（齐次坐标）表示    // TODO : Find out the bounding box of current triangle.    // iterate through the pixel and find if the current pixel is inside the triangle    //（1）用矩形将三角形包围起来,找到矩形的四个顶点，构建三角形包围盒    float min_x = std::floor(std::min(v[0].x(), std::min(v[1].x(), v[2].x())));    float max_x = std::ceil(std::max(v[0].x(), std::max(v[1].x(), v[2].x())));    float min_y = std::floor(std::min(v[0].y(), std::min(v[1].y(), v[2].y())));    float max_y = std::ceil(std::max(v[0].y(), std::max(v[1].y(), v[2].y())));    //（2）遍历三角形包围盒中的所有测试点    for (int x = min_x; x &lt;= max_x; x++)    {        for (int y = min_y; y &lt;= max_y; y++)        {            // If so, use the following code to get the interpolated z value.            //auto[alpha, beta, gamma] = computeBarycentric2D(x, y, t.v);            //float w_reciprocal = 1.0/(alpha / v[0].w() + beta / v[1].w() + gamma / v[2].w());            //float z_interpolated = alpha * v[0].z() / v[0].w() + beta * v[1].z() / v[1].w() + gamma * v[2].z() / v[2].w();            //z_interpolated *= w_reciprocal;            // TODO : set the current pixel (use the set_pixel function) to the color of the triangle (use getColor function) if it should be painted.            //判断是否在三角形内,如果在内部，则将其位置处的插值深度值 (interpolated depth value) 与深度缓冲区 (depth buffer) 中的相应值进行比较。            if (insideTriangle(x, y, t.v))            {                //以下是计算插值的内容，暂时看不懂,先抄别人博客补全                //最小深度，默认是无穷远                float min_depth = FLT_MAX;                //如果在三角形内部，计算当前深度,得到当前最小深度                auto tup = computeBarycentric2D(x + 0.5, y + 0.5, t.v);                float alpha, beta, gamma;                std::tie(alpha, beta, gamma) = tup;                float w_reciprocal = 1.0 / (alpha / v[0].w() + beta / v[1].w() + gamma / v[2].w());                float z_interpolated = alpha * v[0].z() / v[0].w() + beta * v[1].z() / v[1].w() + gamma * v[2].z() / v[2].w();                z_interpolated *= w_reciprocal;                min_depth = std::min(min_depth, z_interpolated);                //如果x,y所在点的深度小于z-buffer的深度，                if (depth_buf[get_index(x, y)] &gt; min_depth)                {                    //获得最上层应该渲染的颜色                    Vector3f color = t.getColor();                    Vector3f point;                    point &lt;&lt; x, y, min_depth;                    //更新深度                    depth_buf[get_index(x, y)] = min_depth;                    //更新所在点的颜色                    set_pixel(point, color);                }            }        }    }}\n\n提高部分\n在上个函数（1）后加入以下部分\n//MSAA 2*2std::vector&lt;Vector2f&gt; multSample{    { 0.25, 0.75 },    { 0.75, 0.75 },    { 0.25, 0.25 },    { 0.75, 0.25 }}; int count = 0; for (int i = 0; i &lt; 4; i++) {     if (insideTriangle(x + multSample[i].x(), y + multSample[i].y(), t.v))     {     \tcount++;     } }\n\n并将原有的if (insideTriangle(x, y, t.v))改为if (count)\n将颜色信息从Vector3f color = t.getColor()修改为Vector3f color = t.getColor() * (count / 4.0)\n","categories":["计算机图形学"],"tags":["笔记","GAMES101","光栅化成像","信号处理"]},{"title":"光栅化成像-视图变换","url":"/2022/05/05/GraphicsNote/01/Graphics01/","content":"现代计算机图形学基础入门光栅化成像视图变换本节内容附加参考资料：\n\n图形学随笔：MVP变换—视图变换 - 哔哩哔哩 (bilibili.com)\nMVP 矩阵变换 - 知乎 (zhihu.com)\n\n我们可以这样来描述视图变换的任务：将虚拟世界中以（x,y,z)为坐标的物体变换到 以一个个像素位置(x,y) 来表示的屏幕坐标系之中(2维)，这确实是一个较为复杂的过程，但是整个过程可以被细分为如下几个步骤：\n\n模型变换\n这一步的目的是将虚拟世界中或者更具体点，游戏场景中的物体调整至他们应该在的位置\n\n\n摄像机变换\n在游戏中我们真正在乎的是摄像机(或者说眼睛)所看到的东西，也就是需要得到物体与摄像机的相对位置\n\n\n投影变换\n在摄像机变换之后，我们得到了所有可视范围内的物体相对于摄像机的相对位置坐标(x,y,z)，之后根据具体情况选择平行投影或是透视投影，将三维空间投影至标准二维平面([-1,1]^2)之上 （tips：这里的z并没有丢掉，为了之后的遮挡关系检测）\n\n\n视口变换\n将处于标准平面映射到屏幕分辨率范围之内，即[-1,1]^2 -&gt; [0,width]*[0,height]其中width和height指屏幕分辨率大小\n\n\n\n\n值得一提的是，以上名词的英文名词较为混乱，简要关系如下：\n\n视图变换（Viewing Transformation）\n\n模型变换(modeling transformation)\n\n摄像机变换(camera transformation)/视角变换(view transformation)\n\n投影变换(projection transformation)\n\n视口变换(viewport transformation)\n\n\n\n\n于是模型变换(M)、视角变换(V)、投影变换(P)的统称为MVP变换，在此名词中视口变换将被孤立\n并且在此之后将会有越来越多的英文名词\n模型变换 M关于模型变换其实在开头部分便已经讲清楚了，就是利用基础的变换矩阵将世界当中的物体调整至我们想要的地方(旋转，平移，缩放)。\n\n[^M矩阵求法]: 按照 缩放——旋转——平移 的顺序进行矩阵变换，因为这种结果是我们需要的\n摄像机变换 V由于摄像机的变换是在世界空间中先旋转后平移得到的，所以需要先反向进行平移变换，再反向进行旋转变换。\n摄像机定义：视图变换需要对摄像机生成的视图有一个唯一的定义，摄像机定义包含三个要素：\n\n位置，用向量 e 表示：显然，一个物体在空间中，肯定是需要一个坐标的；\n朝向，用向量 g 表示：有了位置后，摄像机不同的拍摄角度会生成不同的视图，所以还要定义一个朝向；\n向上的方向，用向量 t 表示：固定好位置与朝向之后，摄像机还是可以360°旋转的，不同的旋转角也会生成不同的视图，所以还需要定义一个向上的方向来描述摄像机的旋转。\n\n由此定义出相对摄像机的坐标系：\n\n\n 摄像机标准位置：如果摄像机和场景的模型，都一起以同一个方式运动，那生成的视图也是一样的，由于生成的视图依赖于摄像机的位置、朝向和其自身的旋转，这样场景中的模型和摄像机之间的相对运动关系就复杂起来了\n为了简化处理，考虑将摄像机变换到一个约定俗成的位置，变换过程大致为\n\n先将摄像机平移至原点\n旋转 g 轴到 -z 轴\n再旋转 t 轴到 y 轴\n最后将 g x t 旋转到 x 轴\n\n同时这个变换过程在场景中的所有模型也同步进行。约定摄像机标准位置如下：\n\n位置在原点，e(0,0,0)；\n\n朝向坐标轴 -z 轴方向，g = -z；\n\n向上的方向是 y 轴方向，t = y；\n\n场景中模型的变换都围绕原点的摄像机进行；\n\n\n总结得出，需要将物体与摄像机一同移动到坐标原点，再进行旋转操作使得摄像机的相对坐标与世界坐标重合\n\n对于平移矩阵T容易得出，归为至原点即可\n\n对于旋转矩阵R，可利用旋转矩阵是正交矩阵的性质，求出由世界坐标旋转至摄像机相对坐标的旋转矩阵后，转置后得到我们需要的旋转矩阵\n\n由此可得出摄像机变换矩阵为\n\n投影变换 P在经过摄像机变换之后得到的依然是三维空间中的顶点坐标，那么如何将其映射至二维空间坐标就交给投影变换完成了，在此分为正交（Orthographic）投影与透视（Perspective）投影\n\n正交投影 Perspective设摄像机距离近裁剪平面的距离为，距离远裁剪平面的距离为，横纵比为，视锥体半高为，则正交矩阵需要做的是\n\n[^[-1, 1]是什么]: 这是每一项的界，这里是将一个物体压缩或者填充到一个中心点在世界坐标原点的立方体中去，这么做的目的是为了计算方便而已，后面会转变会原来的尺寸\n具体实现如图所示，即先将物体平移至坐标原点，之后进行缩放满足要求\n\n其中字母的含义为：\n\n将两者结合可见到这种形式的正交投影矩阵\n\n透视投影 Orthographic透视投影就是最类似人眼所看东西的方式，遵循近大远小，如果说正交投影都是水平光线，那么透视投影则显然不是了\n对应的一点投影后对应的坐标为\n\n于是一个点经过了这样的一个变换过程被投影到了屏幕\n\n所以这个矩阵应该满足\n\n为什么第三列一直未知呢，因为这样的平面分析中，本没有Z的坐标信息，但我们可以推导确定出来\n透视投影有两个性质：\n\n近裁剪平面上的点不会变化\n远裁剪平面的点Z轴信息不会变化\n\n所以不妨设第三行为利用两点性质分别代入远近平面的任意两点就可以列出两个等式\n近裁剪平面上的点不会变化\n\n则可知\n\n将其化为多项式即\n\n远裁剪平面的点Z轴信息不会变化\n同理可得出\n\n二者联立解出\n\n所以透视投影的变化矩阵为\n\n当然这不是完全的透视投影，还需要将其重新正交投影成标准小立方体，故透视投影变化定义为\n\n总和在一起为\n\n视口变化 Vp上一节中一个物体经过了MVP变换后已经被压缩成了一个正则化立方体（Canonical Cube），现在我们需要把它显示到屏幕上了\n屏幕：\n\n像素的集合\n分辨率即是像素的数量\n典型的光栅化显示载体\n\n像素：\n\n\n[^蓝色的像素]: 并不是指将Canonical Cube单独显示在那一点，仅仅是用了同一张图\n这一步十分简单，仅仅是把得到的正则化立方体重新缩放回需要的尺寸\n\n\n作业内容任务目标本次作业的任务是填写一个旋转矩阵和一个透视投影矩阵。给定三维下三个点 v0(2.0, 0.0, −2.0), v1(0.0, 2.0, −2.0), v2(−2.0, 0.0, −2.0), 你需要将这三个点的坐标变换为屏幕坐标并在屏幕上绘制出对应的线框三角形 (在代码框架中，我们已经提供了 draw_triangle 函数，所以你只需要去构建变换矩阵即可)。\n以下是你需要在 main.cpp 中修改的函数：\nEigen::Matrix4f get_model_matrix(float rotation_angle)\n逐个元素地构建模型变换矩阵并返回该矩阵。在此函数中，你只需要实现三维中绕 z 轴旋转的变换矩阵，而不用处理平移与缩放。\nEigen::Matrix4f get_projection_matrix(float eye_fov, float aspect_ratio, float zNear, float zFar)\n使用给定的参数逐个元素地构建透视投影矩阵并返回该矩阵。[Optional] main()\n自行补充你所需的其他操作。\n提高部分：\nEigen::Matrix4f get_rotation(Vector3f axis, float angle)\n在此之中给出按过原点的任意轴旋转的矩阵（罗德里格斯公式）\n代码解释模型变换，以Z轴旋转\nEigen::Matrix4f get_model_matrix(float rotation_angle)//模型变换(以z轴旋转){    Eigen::Matrix4f model = Eigen::Matrix4f::Identity();//单位矩阵初始化// TODO: Implement this function    // Create the model matrix for rotating the triangle around the Z axis.    // Then return it.    float radian = rotation_angle / 180.0 * MY_PI;//转换为弧度制    Eigen::Matrix4f translate;//以z轴旋转    translate &lt;&lt;         cos(radian), -sin(radian), 0, 0,        sin(radian), cos(radian), 0, 0,        0, 0, 1, 0,        0, 0, 0, 1;    model = translate * model;    return model;}`\n\n透视投影变换矩阵\nEigen::Matrix4f get_projection_matrix(float eye_fov, float aspect_ratio,float zNear, float zFar){    // Students will implement this functionEigen::Matrix4f projection = Eigen::Matrix4f::Identity();//单位矩阵初始化    // TODO: Implement this function    // Create the projection matrix for the given parameters.    // Then return it.    Eigen::Matrix4f persp2ortho;//视锥体结构正则化矩阵    persp2ortho &lt;&lt;        zNear, 0, 0, 0,        0, zNear, 0, 0,        0, 0, zNear + zFar, -zNear * zFar,        0, 0, 1, 0;    float halfView = eye_fov * MY_PI / 180.0 / 2;//半视界弧度数    float top = zNear * tan(halfView);//正则化体顶面    float bottom = -top;    float right = top * aspect_ratio;//宽高比得出左右    float left = -right;    Eigen::Matrix4f orthoTrans;//正交投影中坐标正则化    orthoTrans &lt;&lt;        1, 0, 0, -(left + right) / 2,        0, 1, 0, -(top + bottom) / 2,        0, 0, 1, -(zNear + zFar) / 2,        0, 0, 0, 1;    Eigen::Matrix4f orthoScale;//正交投影中比例正则化    orthoScale &lt;&lt;        2 / (right - left), 0, 0, 0,        0, 2 / (top - bottom), 0, 0,        0, 0, 2 / (zNear - zFar), 0,        0, 0, 0, 1;    Eigen::Matrix4f orthoMatrix = orthoScale * orthoTrans;//正交投影    projection = orthoMatrix * persp2ortho;//透视投影    return projection;}\n\n提高部分\nEigen::Matrix4f get_rotation(Vector3f axis, float angle){    Matrix4f model = Matrix4f::Identity();    Matrix4f I = Matrix4f::Identity();    float radian = angle / 180.0 * MY_PI;//转换为弧度制    Vector4f axis_4f;    axis_4f &lt;&lt; axis[0], axis[1], axis[2], 0;    Matrix4f N;    N &lt;&lt;        0, -axis.row(3), axis.row(2), 0,        axis.row(3), 0, -axis.row(0), 0,        -axis.row(2), axis.row(0), 0, 0,        0, 0, 0, 0;    model = cos(radian) * I + (1 - cos(radian)) * axis_4f * axis_4f.transpose() + sin(radian) * N;    model(3, 3) = 1;    return model;}\n","categories":["计算机图形学"],"tags":["笔记","GAMES101","光栅化成像","线性代数"]}]